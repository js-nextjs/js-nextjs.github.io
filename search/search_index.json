{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Next.js is an open-source web development framework built on top of React, which enables web applications with server-side rendering and generating static websites.</p> <pre><code>npx create-next-app@latest next-hello-world\n</code></pre> <p></p>"},{"location":"#let-me-talk-about-history-of-nextjs1","title":"Let me talk about: History of Next.js1","text":"<p>Next.js was released by Vercel (formerly known as Zeit) in 2016. The framework was developed to address issues with React, which was popular at the time but had problems with accessibility, security, slow page loading times, and SEO.</p> <p>Next.js aimed to solve these issues, and has since gained popularity.</p> <p>In 2019, Google began contributing to the project. Today, many large websites such as Walmart, Apple, Nike, Net ix, TikTok, Uber, Lyft, and Starbucks use the framework.</p> <p>Next.js is often credited with completing React by o ering the following features:</p> <ul> <li>Server-Side Rendering</li> <li>Static Site Generation</li> <li>Image Optimization</li> <li>Built-in Routing</li> </ul> <p>These features have made Next.js a popular choice among developers looking to build powerful and performant web applications.</p> <p>Why <code>import * as Next from \"next\"</code> Doesn't Work as Expected</p> Why import <code>*</code> as Next from \"next\" Doesn't Work as Expected <ol> <li> <p>next is a Framework, Not a Regular Module:</p> <ul> <li> <p><code>next</code> is a framework used to build your Next.js application, and it isn't structured like a normal JavaScript module that you can import and log the way you can with React.</p> </li> <li> <p>The <code>next</code> package doesn't expose an object that you can easily access via <code>import * as Next</code>. Instead, it provides a set of API functionalities such as <code>next.config.js</code>, <code>getServerSideProps</code>, <code>getStaticProps</code>, and others for building your app, but they don't expose a central module object that you can just log out directly.</p> </li> </ul> </li> <li> <p>Next.js' Internal Modules Are Not Directly Importable:</p> <ul> <li> <p>Some of the features or utilities that Next.js provides (like <code>next/head</code>, <code>next/router</code>, etc.) are accessible directly by importing them into your code.</p> </li> <li> <p>But trying to import the whole framework with <code>import * as Next from \"next\"</code> doesn\u2019t make sense because it\u2019s not structured to expose a module in that way.</p> </li> </ul> </li> </ol> How to Use Next.js in a Way That Makes Sense ExplanationExample <p>If you're trying to access certain functionalities from Next.js (like the router, head management, etc.), you would need to import specific parts of the Next.js API, like this:</p> <ol> <li> <p>Next.js Router:</p> <pre><code>import { useRouter } from \"next/router\";\nconst router = useRouter();\nconsole.log(router);\n</code></pre> </li> <li> <p>Next.js Head:</p> <pre><code>import Head from \"next/head\";\nconsole.log(Head); // Logs the Head component\n</code></pre> </li> <li> <p>Next.js APIs (getServerSideProps, getStaticProps):</p> <p>You can't really import and log Next.js functions directly in the same way. These are special functions that are part of the framework's lifecycle, so they don\u2019t export a general object.</p> </li> </ol> <p>Example: Proper Usage</p> <p>If you want to explore what\u2019s available in Next.js or just experiment with some of its utilities, here\u2019s an example:</p> <pre><code>// pages/index.js\nimport Head from \"next/head\";\nimport { useRouter } from \"next/router\";\n\nexport default function Home() {\n    const router = useRouter();\n\n    // Log the router object\n    console.log(router);\n\n    return (\n        &lt;div&gt;\n            &lt;Head&gt;\n                &lt;title&gt;Next.js Page&lt;/title&gt;\n            &lt;/Head&gt;\n            &lt;h1&gt;Welcome to Next.js!&lt;/h1&gt;\n        &lt;/div&gt;\n    );\n}\n</code></pre> <p>Summary</p> <p>To sum it up:</p> <ul> <li><code>next</code> doesn\u2019t export a general object like <code>React</code> does. You can\u2019t <code>import * as Next</code> and expect to log the entire framework.</li> <li>If you want to use specific features from Next.js (like routing, head management, etc.), you need to import them individually as needed.</li> </ul> <p>Controlled <code>versus</code> uncontrolled components</p> <p>Controlled components are basically data that is handled by react components, whereas uncontrolled components are data handled by the DOM. The controlled component is basically handled by events or input from the user. Let us look at an example of both:</p> <pre><code>import React, { useState } from \"react\";\n\nconst App = () =&gt; {\n  const [user, setUser] = useState(\"\");\n  return &lt;input type=\"text\" onChange={(e) =&gt; setUser(e.target.value)} /&gt;;\n};\n\nexport default App;\n</code></pre> <p>The preceding code snippet is an example of controlled components. You can see on line 8 that as the user inputs values in the textbox, we are controlling the input by setting the values in the user state.</p> <pre><code>import React, { useRef } from \"react\";\n\nconst App = () =&gt; {\n  const userInpuRef = useRef();\n  return &lt;input type=\"text\" ref={userInputRef} /&gt;;\n};\n\nexport default App;\n</code></pre> <p>The preceding code snippet is an example of uncontrolled components. You can see that we made a reference to the Dom element on line 8. We can get the value of the user by using the ref attribute.(1)</p> <ol> <li>React.js Design Patterns by Anthony Onyekachukwu Okonta</li> </ol>"},{"location":"#rendering-options-on-the-web","title":"Rendering Options on the Web","text":""},{"location":"#courses","title":"Courses \ud83d\udd17","text":"<p>New Project</p> <p> </p> <p>Project Organization</p> <p>To make the folder private, which not expose to the router. we have components folder underscore <code>_components</code> which is nextjs convention.</p> <ul> <li>if the user puts the page.js inside the components folder, the folder will not expose to the route.</li> <li>private folder stays in top because they start with underscore <code>_</code>.</li> </ul> <p><code>../../../</code> instead of this, we can use alias which start from root of the project <code>@</code>.</p> jsconfig.json<pre><code>{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"@/*\": [\"./src/*\"]\n    }\n  }\n}\n</code></pre> <ul> <li>if you put image inside the <code>app</code> folder and named it to the <code>icon</code>. it automatically use that image file to favicon img. it is nextjs convention.</li> </ul> Next js convention <p>what are the nextjs convention.</p>"},{"location":"#reference","title":"Reference","text":"<ul> <li>Dynamic Trio by By Grace Huang, pg: 20</li> </ul>"},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"miscellaneous/intro/","title":"Intro","text":""},{"location":"miscellaneous/intro/#intro","title":"Intro","text":"<ul> <li>Merge: Preserves History, Non-linear History</li> <li>Rebase: Rewrites History, Linear History</li> </ul> <pre><code>docs/\n\u251c\u2500\u2500 websockets/\n\u2502   \u251c\u2500\u2500 introduction.md\n\u2502   \u251c\u2500\u2500 setup.md\n\u2502   \u251c\u2500\u2500 examples.md\n\u2502   \u2514\u2500\u2500 troubleshooting.md\n\u2514\u2500\u2500 push-notifications/\n    \u251c\u2500\u2500 introduction.md\n    \u251c\u2500\u2500 setup.md\n    \u251c\u2500\u2500 examples.md\n    \u2514\u2500\u2500 best-practices.md\n\n\nnav:\n  - Home: index.md\n  - WebSockets:\n      - Introduction: websockets/introduction.md\n      - Setup: websockets/setup.md\n      - Examples: websockets/examples.md\n      - Troubleshooting: websockets/troubleshooting.md\n  - Push Notifications:\n      - Introduction: push-notifications/introduction.md\n      - Setup: push-notifications/setup.md\n      - Examples: push-notifications/examples.md\n      - Best Practices: push-notifications/best-practices.md\n</code></pre> <p>uncaught referenceerror can t access lexical declaration before initialization</p> <pre><code>uncaught referenceerror can t access lexical declaration before initialization\n\n// axiosBaseQuery.js\nimport axiosInstance from \"./axiosInstance\";\n\nexport const axiosBaseQuery =\n  ({ baseUrl } = { baseUrl: \"\" }) =&gt;\n  async ({ url, method, meta, data, params, headers }) =&gt; {\n    try {\n      const result = await axiosInstance.base({\n        url: baseUrl + url,\n        method,\n        meta,\n        data,\n        params,\n        headers,\n      });\n\n      return { data: result.data, meta: { ...meta, method } };\n    } catch (axiosError) {\n      const err = axiosError;\n      return {\n        error: {\n          status: err.response?.status,\n          data: err.response?.data || err.message,\n          meta: { ...meta, method },\n        },\n      };\n    }\n  };\n\n// export default axiosBaseQuery;\n\n\n// passwordReset.js\nimport { createApi } from \"@reduxjs/toolkit/query/react\";\nimport { axiosBaseQuery } from \"@shared/services/axios/axiosBaseQuery\";\nimport { HTTP_METHODS } from \"@shared/utils/httpMethods\";\nimport { CONFIG } from \"@shared/utils/config\";\nimport logger from \"@shared/utils/logger\";\n\nexport const passwordApi = createApi({\n  reducerPath: \"passwordApi\",\n  baseQuery: axiosBaseQuery({\n    baseUrl: CONFIG.API_BASE_URL,\n  }),\n  endpoints: (builder) =&gt; ({\n    postPasswordReset: builder.mutation({\n      query: ({ id, data }) =&gt; ({\n        url: `Users/password-reset/${id}`,\n        method: HTTP_METHODS.POST,\n        data,\n      }),\n    }),\n  }),\n});\n\nexport const { usePostPasswordResetMutation } = passwordApi;\n\n\n// axiosInstace.js\n\nimport axios from \"axios\";\nimport { store } from \"@shared/store/store\";\nimport axiosConfig from \"./axiosConfig\";\n\nconst axiosInstance = {\n  base: axios.create({\n    baseURL: import.meta.env.VITE_REACT_APP_BASE_API_URL,\n    ...axiosConfig,\n  }),\n  login: axios.create({\n    baseURL: import.meta.env.VITE_REACT_APP_LOGIN_API_URL,\n    ...axiosConfig,\n  }),\n};\n\naxiosInstance.base.interceptors.request.use(\n  (config) =&gt; {\n    const state = store.getState();\n    const token = state.auth.token;\n\n    if (token) {\n      config.headers[\"Authorization\"] = `Bearer ${token}`;\n    }\n    return config;\n  },\n  (error) =&gt; {\n    return Promise.reject(error);\n  }\n);\n\nexport default axiosInstance;\n\n\n// config.js\nexport const CONFIG = {\n  BASE_URL: import.meta.env.VITE_REACT_APP_LOGIN_API_URL,\n  API_BASE_URL: import.meta.env.VITE_REACT_APP_BASE_API_URL,\n  LOGIN_URL: import.meta.env.VITE_REACT_APP_DUMMY_API_URL,\n  LOG_LEVEL: import.meta.env.VITE_REACT_APP_LOG_LEVEL,\n  MODE: import.meta.env.MODE,\n};\n\nexport const OAUTH = {\n  CLIENT_ID: import.meta.env.VITE_REACT_APP_CLIENT_ID,\n  CLIENT_SECRET: import.meta.env.VITE_REACT_APP_CLIENT_SECRET,\n  SCOPE: import.meta.env.VITE_REACT_APP_SCOPE,\n  GRANT_TYPE: import.meta.env.VITE_REACT_APP_GRANT_TYPE,\n};\n</code></pre> <p>The error message <code>Uncaught ReferenceError: Can't access lexical declaration before initialization</code> typically occurs when a variable declared using let, const, or class is accessed before its initialization in the code. This is a result of the temporal dead zone (TDZ) behavior in JavaScript, where variables declared with <code>let</code> or <code>const</code> are hoisted but not initialized until their declaration is evaluated at runtime.</p> The Root Cause <p>In your case, this error is likely happening because of how the imports and the execution flow are handled in the file.</p> <p>Here's the flow of what might be happening:</p> <ol> <li><code>axiosBaseQuery.js</code> exports <code>axiosBaseQuery</code> (an asynchronous function).</li> <li><code>passwordReset.js</code> imports <code>axiosBaseQuery</code> and uses it in the createApi function from Redux Toolkit.</li> </ol> <p>The error occurs when <code>axiosBaseQuery</code> is being imported and used before it is fully initialized.</p> Why it Happens <p>It seems the problem arises due to how you're using <code>axiosBaseQuery</code> in the <code>baseQuery</code> property. Since <code>axiosBaseQuery</code> is a function that uses <code>async/await</code>, it might be referencing some state or other imports that could be running before the module is fully initialized. The error might be appearing because you are trying to use something (likely part of the <code>baseUrl</code> or the configuration) before it\u2019s ready.</p> Possible Solutions <ol> <li> <p>Rearrange imports in <code>passwordReset.js</code>:</p> <p>Try reordering the imports in <code>passwordReset.js</code> to ensure that the <code>axiosBaseQuery</code> is fully initialized before it\u2019s used:</p> <pre><code>import { axiosBaseQuery } from \"@shared/services/axios/axiosBaseQuery\";\nimport { createApi } from \"@reduxjs/toolkit/query/react\";\nimport { HTTP_METHODS } from \"@shared/utils/httpMethods\";\nimport { CONFIG } from \"@shared/utils/config\";\nimport logger from \"@shared/utils/logger\";\n</code></pre> </li> </ol> <ul> <li>ReferenceError: can't access lexical declaration`X' before initialization</li> <li>ReferenceError: can't access lexical declaration before initialization when using createAsyncThunk with createReducer #687</li> <li> <p>ReferenceError: can't access lexical declaration 'X' before initialization</p> </li> <li> <p>Using Axios Instance with Interceptors in Redux Toolkit Query (RTK Query)</p> </li> </ul> when to use () and when to use {}<pre><code>const api = createApi({\n  baseQuery: axiosBaseQuery({\n    baseUrl: \"https://example.com\",\n  }),\n  endpoints(build) {\n    return {\n      query: build.query({ query: () =&gt; ({ url: \"/query\", method: \"get\" }) }),\n      mutation: build.mutation({\n        query: () =&gt; ({ url: \"/mutation\", method: \"post\" }),\n      }),\n    };\n  },\n});\n</code></pre> <ul> <li>GIST: Axios Base Query for RTK Query (redux toolkit)</li> </ul> <p>Warning: Instance created by <code>useForm</code> is not connected to any Form element. Forget to pass <code>form</code> prop?</p> <ul> <li>Github: Incorrect console warning on useForm is not connected to Form eleme</li> </ul>"},{"location":"miscellaneous/intro/#memo","title":"memo","text":"<p><code>React.memo</code> is a higher-order component (HOC) that memoizes the component, which prevents unnecessary re-renders. I</p> <p><code>React.memo</code> performs a shallow comparison of the props passed to the component. This means that if any prop is a complex object (e.g., an array or an object) and it changes reference, <code>React.memo</code> will trigger a re-render even if the object's contents haven't changed.</p>"},{"location":"miscellaneous/intro/#antd-form-submit-button-outside-form","title":"Antd Form Submit Button Outside Form","text":"<p>The issue you're encountering is that the \"Submit\" button doesn't trigger the <code>handleReset</code> function, even though the form's <code>onFinish</code> event is tied to it. This is likely because the button's <code>htmlType=\"submit\"</code> doesn't properly trigger the form submission, possibly due to how the button is being handled or the form's validation requirements.</p> <p>To ensure the <code>handleReset</code> function is properly called when the \"Submit\" button is clicked, here's what you can check and fix:</p> <ol> <li> <p>Ensure the Button is Inside the Form</p> <p>Make sure that the <code>Submit</code> button is within the <code>Form</code> component. This is necessary for the <code>htmlType=\"submit\"</code> to work properly, as it tells the form to trigger the onFinish event.</p> </li> <li> <p>Add <code>onFinishFailed</code> if Needed</p> <p>If the form has validation rules, you might want to handle cases where validation fails. However, this isn't necessary unless you have validation rules in place.</p> </li> <li> <p>Fix Button Outside of Form: If you still want the button to trigger the form submission but keep it outside of the <code>Form</code> component, you can use the <code>form.submit()</code> method programmatically.</p> </li> </ol> CodeExplanation <pre><code>import React, { useId } from \"react\";\nimport { Drawer, Button, Space, Form, Input } from \"antd\";\nimport logger from \"@shared/utils/logger\";\n\nconst PasswordReset = React.memo(({ id, visible, onClose }) =&gt; {\n    const [form] = Form.useForm();\n\n    const handleReset = (values) =&gt; {\n        // Log the form values\n        logger.info({ msg: \"RESET\", values });\n    };\n\n    return (\n        &lt;Drawer\n            title=\"Reset Password\"\n            open={visible}\n            onClose={() =&gt; {\n                onClose();\n                form.resetFields();\n            }}\n            closable={false}\n            footer={\n                &lt;Space&gt;\n                &lt;Button onClick={onClose}&gt;Cancel&lt;/Button&gt;\n                &lt;Button\n                    type=\"primary\"\n                    onClick={() =&gt; form.submit()} // Trigger the form submission programmatically\n                &gt;\n                    Submit\n                &lt;/Button&gt;\n                &lt;/Space&gt;\n            }\n        &gt;\n            &lt;Form form={form} layout=\"vertical\" onFinish={handleReset}&gt;\n                &lt;Form.Item\n                    name=\"password\"\n                    label=\"Password\"\n                    rules={[\n                        {\n                        required: true,\n                        message: \"Please enter your new password\",\n                        },\n                    ]}\n                &gt;\n                    &lt;Input.Password\n                        placeholder=\"Enter new password\"\n                        autoComplete=\"new-password\"\n                    /&gt;\n                &lt;/Form.Item&gt;\n            &lt;/Form&gt;\n        &lt;/Drawer&gt;\n    );\n});\n\nexport default PasswordReset;\n</code></pre> <p>Explanation of Changes:</p> <ol> <li> <p><code>form.submit()</code>:</p> <p>The <code>onClick</code> of the \"Submit\" button now calls <code>form.submit()</code>. This will trigger the form's <code>onFinish</code> event manually, even if the button is outside the form. This ensures that the form will submit and call the <code>handleReset</code> function.</p> </li> <li> <p>Validation Rule for Password:</p> <p>I added a simple validation rule (<code>required: true</code>) to the <code>Form.Item</code> to ensure the form won't submit without a password. This can be customized according to your requirements.</p> </li> <li> <p><code>onFinish</code> Handling:</p> <p>The <code>handleReset</code> function will receive the form values when it's triggered. You can then log or process them.</p> </li> </ol> <p>How It Works:</p> <ul> <li>When you click the \"Submit\" button, it calls <code>form.submit()</code>, which submits the form and triggers the <code>onFinish</code> event.</li> <li>The <code>handleReset</code> function is triggered, and the form values are logged.</li> </ul> success <pre><code>// Internal\nimport React, { useId, useState } from \"react\";\n// Theme\nimport { Drawer, Button, Space, Form, Input } from \"antd\";\n// Shared\nimport { validatePassword } from \"@shared/utils/validatePassword\";\nimport { usePostPasswordResetMutation } from \"@features/settings/services/passwordApi\";\n// Log\nimport logger from \"@shared/utils/logger\";\n\nconst PasswordReset = React.memo(({ id, visible, onClose }) =&gt; {\n    const [form] = Form.useForm();\n    const [isLoadingButton, setIsLoadingButton] = useState(false);\n\n    const [postPasswordReset, { isLoading, isError, error }] =\n        usePostPasswordResetMutation();\n\n    const handleReset = async (values) =&gt; {\n        setIsLoadingButton(true);\n        try {\n            logger.info({ msg: \"RESET\", values, id });\n            await postPasswordReset({ id, data: values }).unwrap();\n            form.resetFields();\n            onClose();\n        } catch (error) {\n            logger.error({ msg: \"RESET Password\", error });\n        } finally {\n            setIsLoadingButton(false);\n        }\n    };\n\n    return (\n        &lt;Drawer\n            title=\"Reset Password\"\n            open={visible}\n            onClose={() =&gt; {\n                onClose();\n                form.resetFields();\n            }}\n            closable={false}\n            footer={\n                &lt;Space&gt;\n                    &lt;Button onClick={onClose}&gt;Cancel&lt;/Button&gt;\n                    &lt;Button\n                        type=\"primary\"\n                        onClick={() =&gt; {\n                            form\n                                .validateFields()\n                                .then((values) =&gt; {\n                                handleReset(values);\n                                })\n                                .catch((errorInfo) =&gt; {\n                                logger.error({ msg: \"Error\", errorInfo });\n                                });\n                        }}\n                        htmlType=\"submit\"\n                    &gt;\n                        Submit\n                    &lt;/Button&gt;\n                &lt;/Space&gt;\n            }\n        &gt;\n            &lt;Form form={form} layout=\"vertical\" onFinish={handleReset}&gt;\n                &lt;Form.Item\n                    name=\"newPassword\"\n                    label=\"Password\"\n                    rules={[\n                        {\n                        required: true,\n                        // message: \"Please enter password\",\n                        },\n                        { validator: validatePassword },\n                    ]}\n                    hasFeedback\n                &gt;\n                &lt;Input.Password\n                    placeholder=\"Enter new password\"\n                    autoComplete=\"new-password\"\n                /&gt;\n                &lt;/Form.Item&gt;\n            &lt;/Form&gt;\n        &lt;/Drawer&gt;\n    );\n});\n\nexport default PasswordReset;\n</code></pre> <p>Modified Code</p> <p>To ensure the form is submitted only when the validatePassword function passes (i.e., the password validation succeeds), you need to modify the logic in the PasswordReset component, specifically the part where you trigger the form submission.</p> StepsCODEKey Changes: <p>Here\u2019s how you can modify the PasswordReset component:</p> <p>Key Steps:</p> <ol> <li>Ensure that <code>validatePassword</code> runs before submitting the form.</li> <li>Only submit the form when <code>validatePassword</code> passes.</li> </ol> <p>Modifications to your existing code:</p> <ul> <li>You need to modify the logic where you check for form submission (<code>onClick</code> handler for the submit button).</li> <li>Since <code>validatePassword</code> already handles the validation within the <code>Form.Item</code>, the form will automatically stop submission if the validation fails.</li> <li>If you want to explicitly control the validation, you can use the <code>form.validateFields()</code> method to trigger validation manually.</li> </ul> <pre><code>import React, { useId } from \"react\";\nimport { Drawer, Button, Space, Form, Input } from \"antd\";\nimport { validatePassword } from \"@shared/utils/validatePassword\";\nimport logger from \"@shared/utils/logger\";\n\nconst PasswordReset = React.memo(({ id, visible, onClose }) =&gt; {\n    const [form] = Form.useForm();\n\n    const handleReset = (values) =&gt; {\n        logger.info({ msg: \"RESET\", values });\n    };\n\n    const handleSubmit = () =&gt; {\n        // Manually trigger validation before form submission\n        form\n            .validateFields() // This triggers validation for all fields\n            .then((values) =&gt; {\n                // If validation is successful, call handleReset\n                handleReset(values);\n            })\n            .catch((errorInfo) =&gt; {\n                // Handle validation failure (if necessary)\n                console.log(\"Validation failed:\", errorInfo);\n            });\n    };\n\n    return (\n        &lt;Drawer\n            title=\"Reset Password\"\n            open={visible}\n            onClose={() =&gt; {\n                onClose();\n                form.resetFields();\n            }}\n            closable={false}\n            footer={\n                &lt;Space&gt;\n                    &lt;Button onClick={onClose}&gt;Cancel&lt;/Button&gt;\n                    &lt;Button\n                        type=\"primary\"\n                        onClick={handleSubmit} // Use handleSubmit instead of directly submitting\n                        htmlType=\"submit\"\n                    &gt;\n                        Submit\n                    &lt;/Button&gt;\n                &lt;/Space&gt;\n            }\n        &gt;\n            &lt;Form form={form} layout=\"vertical\" onFinish={handleReset}&gt;\n                &lt;Form.Item\n                    name=\"password\"\n                    label=\"Password\"\n                    rules={[\n                        {\n                        required: true,\n                        // message: \"Please enter password\",\n                        },\n                        { validator: validatePassword },\n                    ]}\n                    hasFeedback\n                &gt;\n                    &lt;Input.Password\n                        placeholder=\"Enter new password\"\n                        autoComplete=\"new-password\"\n                    /&gt;\n                &lt;/Form.Item&gt;\n            &lt;/Form&gt;\n        &lt;/Drawer&gt;\n    );\n});\n\nexport default PasswordReset;\n</code></pre> <ol> <li> <p><code>handleSubmit</code> method: This is where we explicitly call <code>form.validateFields()</code>. If the validation passes (i.e., the password matches the validation criteria), it will proceed to call <code>handleReset</code>. If validation fails, it will not submit the form.</p> </li> <li> <p>Form submission: Instead of directly calling <code>form.submit()</code> in the button's <code>onClick</code>, we call the <code>handleSubmit</code> method, which handles both validation and submission.</p> </li> </ol> <p>This setup ensures that the form will only submit if the password passes all validation criteria specified in <code>validatePassword</code>.</p>"},{"location":"miscellaneous/intro/#bug","title":"Bug","text":"<p>Warning: React does not recognize the <code>hasFeedback</code> prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase <code>hasfeedback</code> instead. If you accidentally passed it from a parent component, remove it from the DOM element. Component Stack: </p> <ul> <li>Official React: memo</li> <li>W3Schools: React Memo</li> </ul>"},{"location":"miscellaneous/practical/","title":"Practical","text":""},{"location":"miscellaneous/practical/#system-requirements","title":"System Requirements","text":"<ul> <li><code>Node.js 18.18</code> or later.</li> <li>macOS, Windows (including WSL), and Linux are supported.</li> </ul>"},{"location":"miscellaneous/practical/#automatic-installation","title":"Automatic installation","text":"<p>We recommend starting a new Next.js app using create-next-app, which sets up everything automatically for you. To create a project, run:</p> <pre><code>npx create-next-app@latest\n</code></pre>"},{"location":"miscellaneous/practical/#manual-installation","title":"Manual installation","text":"<pre><code>npm install next@latest react@latest react-dom@latest\n</code></pre>"},{"location":"miscellaneous/practical/#run-the-development-server","title":"Run the development server","text":"<ul> <li>Run npm run dev to start the development server.</li> <li>Visit http://localhost:3000 to view your application.</li> <li>Edit <code>theapp/page.tsx</code> file and save it to see the updated result in your browser.</li> </ul>"},{"location":"miscellaneous/practical/#set-up-typescript","title":"Set up TypeScript","text":"<p><code>Minimum TypeScript version: v4.5.2</code></p> <p>Next.js comes with built-in TypeScript support. To add TypeScript to your project, rename a file to <code>.ts</code> / <code>.tsx</code>. Run <code>next dev</code>, Next.js will automatically install the necessary dependencies and add a <code>tsconfig.json</code> file with the recommended config options.</p>"},{"location":"miscellaneous/practical/#set-up-eslint","title":"Set up ESLint","text":"<p>Next.js comes with built-in ESLint, automatically installing the necessary packages and configuring the proper settings when you create a new project with <code>create-next-app</code>.</p> <p>To add ESLint to an existing project, add <code>next lint</code> as a script to <code>package.json</code>:</p> package.json<pre><code>{\n  \"scripts\": {\n    \"lint\": \"next lint\"\n  }\n}\n</code></pre> <p>Then, run <code>npm run lint</code> and you will be guided through the installation and configuration process.</p> <pre><code>pnpm lint\n</code></pre>"},{"location":"miscellaneous/practical/#set-up-absolute-imports-and-module-path-aliases","title":"Set up Absolute Imports and Module Path Aliases","text":"<p>Next.js has in-built support for the <code>\"paths\"</code> and <code>\"baseUrl\"</code> options of <code>tsconfig.json</code> and <code>jsconfig.json</code> files. These options allow you to alias project directories to absolute paths, making it easier to import modules. For example:</p> <pre><code>// Before\nimport { Button } from \"../../../components/button\";\n\n// After\nimport { Button } from \"@/components/button\";\n</code></pre> <p>To configure absolute imports, add the <code>baseUrl</code> configuration option to your <code>tsconfig.json</code> or <code>jsconfig.json</code> file. For example:</p> tsconfig.json or jsconfig.json<pre><code>{\n  \"compilerOptions\": {\n    \"baseUrl\": \"src/\"\n  }\n}\n</code></pre> <p>In addition to configuring the <code>baseUrl</code> path, you can use the <code>\"paths\"</code> option to <code>\"alias\"</code> module paths.</p> <p>For example, the following configuration maps <code>@/components/*</code> to <code>components/*</code>:</p> tsconfig.json or jsconfig.json<pre><code>{\n  \"compilerOptions\": {\n    \"baseUrl\": \"src/\",\n    \"paths\": {\n      \"@/styles/*\": [\"styles/*\"],\n      \"@/components/*\": [\"components/*\"]\n    }\n  }\n}\n</code></pre> <p>Each of the <code>\"paths\"</code> are relative to the <code>baseUrl</code> location. For example:</p> src/app/page.tsx<pre><code>import Button from \"@/components/button\";\nimport \"@/styles/styles.css\";\n\nexport default function HomePage() {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Hello World&lt;/h1&gt;\n      &lt;Button /&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"miscellaneous/practical/#reference","title":"Reference","text":"<ul> <li>Docs: Installation, nextjs.org</li> </ul>"},{"location":"miscellaneous/hoc/hooks-vs-hocs/","title":"Hooks vs HoC","text":""},{"location":"miscellaneous/hoc/hooks-vs-hocs/#hooks-vs-hocs-which-is-better","title":"\u2705 Hooks vs HOCs: Which is Better?","text":"<p>You're right! Hooks are often better and more modern than HOCs for handling shared logic in React. However, both patterns have their place. Let me clarify:</p>"},{"location":"miscellaneous/hoc/hooks-vs-hocs/#hocs-vs-hooks-key-differences","title":"\ud83c\udd9a HOCs vs Hooks: Key Differences","text":"Aspect Higher-Order Components (HOCs) Hooks Introduced in React 16.0 React 16.8 Code Reusability Wrap components to add functionality Reuse logic directly in functional components Complexity Can lead to wrapper hell (nested HOCs) Simpler and cleaner code Performance Slightly slower due to component wrapping Faster and more direct UI Manipulation Harder to manipulate UI inside HOCs Easier to control UI with hooks Stateful Logic Harder to manage complex state logic Hooks handle complex state elegantly Modern Approach Older pattern Recommended for new projects"},{"location":"miscellaneous/hoc/hooks-vs-hocs/#example-data-fetching","title":"\ud83e\uddea Example: Data Fetching","text":"\ud83c\udfd7\ufe0f Using HOC for Data Fetching<pre><code>const withDataFetching = (WrappedComponent, url) =&gt; {\n  return (props) =&gt; {\n    const [data, setData] = useState(null);\n    const [loading, setLoading] = useState(true);\n\n    useEffect(() =&gt; {\n      fetch(url)\n        .then((response) =&gt; response.json())\n        .then((data) =&gt; {\n          setData(data);\n          setLoading(false);\n        });\n    }, [url]);\n\n    if (loading) return &lt;h2&gt;Loading...&lt;/h2&gt;;\n\n    return &lt;WrappedComponent {...props} data={data} /&gt;;\n  };\n};\n\nconst UserList = ({ data }) =&gt; (\n  &lt;ul&gt;\n    {data.map((user) =&gt; (\n      &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;\n    ))}\n  &lt;/ul&gt;\n);\n\nexport default withDataFetching(\n  UserList,\n  \"https://jsonplaceholder.typicode.com/users\"\n);\n</code></pre> \ud83d\ude80 Using Hooks for Data Fetching (Better Way)<pre><code>import { useState, useEffect } from \"react\";\n\nconst useFetchData = (url) =&gt; {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() =&gt; {\n    fetch(url)\n      .then((response) =&gt; response.json())\n      .then((data) =&gt; {\n        setData(data);\n        setLoading(false);\n      });\n  }, [url]);\n\n  return { data, loading };\n};\n\nconst UserList = () =&gt; {\n  const { data, loading } = useFetchData(\n    \"https://jsonplaceholder.typicode.com/users\"\n  );\n\n  if (loading) return &lt;h2&gt;Loading...&lt;/h2&gt;;\n\n  return (\n    &lt;ul&gt;\n      {data.map((user) =&gt; (\n        &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n};\n\nexport default UserList;\n</code></pre>"},{"location":"miscellaneous/hoc/hooks-vs-hocs/#why-hooks-are-better-in-modern-react","title":"\ud83d\udd11 Why Hooks Are Better in Modern React:","text":"<ol> <li> <p>Cleaner Code:</p> <p>No need to create a separate wrapper component.</p> </li> <li> <p>Avoid Wrapper Hell:</p> <p>HOCs can cause nested components (wrapper hell), making your component tree harder to understand and debug.</p> </li> <li> <p>Flexible and Composable:</p> <p>Hooks are more flexible and easier to compose compared to HOCs. You can combine multiple hooks within a single component.</p> </li> <li> <p>Direct Access to State and Lifecycle:</p> <p>Hooks give direct access to state and lifecycle methods, making it easier to manage complex logic.</p> </li> </ol>"},{"location":"miscellaneous/hoc/hooks-vs-hocs/#when-should-you-use-hocs","title":"\ud83d\udcda When Should You Use HOCs?","text":"<p>Despite hooks being better, there are some cases where HOCs are still useful:</p> <ul> <li>\u2705 Access Control (Authorization HOCs)</li> <li>\u2705 Adding Global Logic (Logging, Error Boundaries)</li> <li>\u2705 Theming HOCs</li> <li>\u2705 Codebases that haven\u2019t migrated to hooks yet</li> </ul>"},{"location":"miscellaneous/hoc/hooks-vs-hocs/#conclusion","title":"\ud83d\udca1 Conclusion:","text":"<ul> <li>\ud83d\udc49 Use Hooks for most cases.</li> <li>\ud83d\udc49 Use HOCs only if you're dealing with access control, theming, or legacy codebases that already rely on HOCs.</li> </ul>"},{"location":"miscellaneous/hoc/hooks/","title":"Hooks Reference","text":""},{"location":"miscellaneous/hoc/hooks/#hooks-to-fuel-your-web-applications","title":"Hooks to fuel your web applications","text":"<p>Hooks are a special kind of creature in the React biosphere. From the outside, they seem completely unrelated in functionality, but when examined closer, they have some common traits and behaviors that we need to account for when using them. You could say that they stem from a common ancestor somewhere in the evolutionary tree, even though they have advanced to become very different beings.</p> <p>You've seen three different hooks up until now: useState (in chapter 5) plus <code>useEffect</code> and <code>useLayoutEffect</code> (in chapter 6). There are at this time 15 built-in hooks in React (as of <code>React 18</code>) and we're going to briefly cover all of them grouped by their functionality.</p> <ul> <li> <p>The stateful hooks. These are functions that are concerned with making components and applications stateful on several different layers and levels of complexity: <code>useState</code>, <code>useReducer</code>, <code>useRef</code>, <code>useContext</code>, <code>useDeferredValue</code>, and <code>useTransition</code>.</p> </li> <li> <p>The effect hooks. These are functions that are concerned with running effects inside a component at different stages of the overall component lifecycle as well as during each individual render cycle: <code>useEffect</code> and <code>useLayoutEffect</code>.</p> </li> <li> <p>The memoization hooks. These are functions that are used for performance optimization via avoiding re-calculating values, if their constituent parts haven't changed: <code>useMemo</code>, <code>useCallback</code>, <code>useId</code>.</p> </li> <li> <p>The library hooks. These are advanced functions almost exclusively used in larger component libraries that are created to be shared either with the community or internally in a larger organization. These functions are rarely used in smaller or medium-size applications: <code>useDebugValue</code>, <code>useImperativeHandle</code>, <code>useInsertionEffect</code>, and <code>useSyncExternalStore</code>.</p> </li> </ul> <p>These 15 hooks are the built-in \"base\" hooks that React comes with. You can build more hooks on top of that, but you cannot build your own \"base\" hooks.</p> <p>You can only build hooks that utilize one or more of the existing hooks. We will be discussing custom hooks in future chapters a couple of times. Do note that React might be extended with more built-in hooks in future releases. <code>React 18.0</code> came with 5 new hooks, and incremental releases after React 18 might come with even more.</p> React New Hooks <ul> <li>useId</li> <li>useDeferredValue</li> <li>useTransition</li> <li>useSyncExternalStore</li> <li>useInsertionEffect</li> </ul>"},{"location":"miscellaneous/hoc/hooks/#reference","title":"Reference","text":"<ul> <li>Book: React Quickly, Second Edition MEAP V1 by Morten Barklund and Azat Mardan, pg: 288</li> <li>Example: New Hooks in React 18, geeksforgeeks.org</li> <li>Example: Using New Hooks in Rect 18</li> <li>Oficial Site: Hooks by Category, legacy</li> <li>Oficial Site: Functional Update, legacy</li> </ul>"},{"location":"miscellaneous/hoc/intro/","title":"Intro","text":""},{"location":"miscellaneous/hoc/intro/#what-is-a-higher-order-component-hoc-in-react","title":"\ud83d\udcda What is a Higher-Order Component (HOC) in React?","text":"<p>A Higher-Order Component (HOC) is a function that takes a component as an argument and returns a new component. It allows you to reuse component logic by wrapping one or more components in a new component with additional functionality.</p> <p>HOCs follow the principle of \"don't repeat yourself\" (DRY) by abstracting shared logic that can be reused across multiple components.</p>"},{"location":"miscellaneous/hoc/intro/#when-to-use-a-higher-order-component-hoc","title":"\u2699\ufe0f When to Use a Higher-Order Component (HOC)","text":"<p>Here are some common scenarios where you can use HOCs:</p> <ol> <li> <p>Access Control (Authorization)</p> <p>To protect routes or restrict access to certain components based on user roles or authentication status.</p> </li> <li> <p>Data Fetching / API Integration</p> <p>Wrap components to handle data fetching logic and pass the data as props.</p> </li> <li> <p>Conditional Rendering</p> <p>Dynamically show or hide components based on certain conditions.</p> </li> <li> <p>Logging and Analytics</p> <p>Track user interactions with specific components.</p> </li> <li> <p>Theming / Styling</p> <p>Apply consistent styles or themes to multiple components.</p> </li> <li> <p>Performance Optimization</p> <p>Use memoization or lazy loading to optimize the performance of wrapped components.</p> </li> </ol>"},{"location":"miscellaneous/hoc/intro/#syntax-of-a-higher-order-component-in-react","title":"\ud83d\udcc4 Syntax of a Higher-Order Component in React","text":"\u2705 Basic HOC Syntax:<pre><code>import React from \"react\";\n\n// Higher-Order Component\nconst withExtraProps = (WrappedComponent) =&gt; {\n  return (props) =&gt; {\n    // Add new props or modify existing props\n    const extraProps = { additionalData: \"Hello from HOC\" };\n\n    // Return the wrapped component with new props\n    return &lt;WrappedComponent {...props} {...extraProps} /&gt;;\n  };\n};\n\n// Component to be wrapped\nconst MyComponent = (props) =&gt; {\n  return &lt;div&gt;{props.additionalData}&lt;/div&gt;;\n};\n\n// Using the HOC\nconst EnhancedComponent = withExtraProps(MyComponent);\n\nexport default EnhancedComponent;\n</code></pre>"},{"location":"miscellaneous/hoc/intro/#example-use-cases-of-hocs","title":"\ud83d\udcc2 Example Use Cases of HOCs","text":"\u2705 1. Authorization HOC (Access Control):<pre><code>const withAuthorization = (WrappedComponent) =&gt; {\n  return (props) =&gt; {\n    const isAuthenticated = localStorage.getItem(\"token\");\n\n    if (!isAuthenticated) {\n      return &lt;h1&gt;Access Denied. Please log in.&lt;/h1&gt;;\n    }\n\n    return &lt;WrappedComponent {...props} /&gt;;\n  };\n};\n\nconst Dashboard = (props) =&gt; {\n  return &lt;h1&gt;Welcome to your Dashboard!&lt;/h1&gt;;\n};\n\nconst ProtectedDashboard = withAuthorization(Dashboard);\nexport default ProtectedDashboard;\n</code></pre> \u2705 2. Data Fetching HOC:<pre><code>import React, { useEffect, useState } from \"react\";\nimport axios from \"axios\";\n\nconst withDataFetching = (WrappedComponent, url) =&gt; {\n  return (props) =&gt; {\n    const [data, setData] = useState(null);\n    const [loading, setLoading] = useState(true);\n\n    useEffect(() =&gt; {\n      axios.get(url).then((response) =&gt; {\n        setData(response.data);\n        setLoading(false);\n      });\n    }, [url]);\n\n    if (loading) return &lt;h2&gt;Loading...&lt;/h2&gt;;\n\n    return &lt;WrappedComponent {...props} data={data} /&gt;;\n  };\n};\n\nconst UserList = ({ data }) =&gt; {\n  return (\n    &lt;ul&gt;\n      {data.map((user) =&gt; (\n        &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n};\n\nexport default withDataFetching(\n  UserList,\n  \"https://jsonplaceholder.typicode.com/users\"\n);\n</code></pre> \u2705 3. Logging HOC:<pre><code>const withLogging = (WrappedComponent) =&gt; {\n  return (props) =&gt; {\n    useEffect(() =&gt; {\n      console.log(\"Component Mounted:\", WrappedComponent.name);\n    }, []);\n\n    return &lt;WrappedComponent {...props} /&gt;;\n  };\n};\n\nconst Button = (props) =&gt; {\n  return &lt;button&gt;{props.label}&lt;/button&gt;;\n};\n\nexport default withLogging(Button);\n</code></pre>"},{"location":"miscellaneous/hoc/intro/#key-points-to-remember-about-hocs","title":"\ud83d\udee0\ufe0f Key Points to Remember about HOCs:","text":"<ol> <li> <p>Pure Functions:</p> <p>HOCs are pure functions, meaning they don't modify the original component.</p> </li> <li> <p>Props Passing:</p> <p>Always pass the original props to the wrapped component to ensure no data is lost.</p> <pre><code>return &lt;WrappedComponent {...props} /&gt;;\n</code></pre> </li> <li> <p>Naming Convention:</p> <p>It\u2019s a convention to prefix the HOC function with \"with\" (e.g., <code>withAuthorization</code>, <code>withLogging</code>).</p> </li> <li> <p>Don't Use HOCs Inside the Render Method:</p> <p>Never create HOCs inside a component's render method. It can cause performance issues.</p> </li> </ol>"},{"location":"miscellaneous/hoc/intro/#when-to-use-hocs-vs-other-patterns-hooks-render-props","title":"\ud83e\udd14 When to Use HOCs vs Other Patterns (Hooks, Render Props)?","text":"Scenario Use HOC Use Hooks Reusing logic across components \u2705 \u2705 Access control (Auth) \u2705 \u2705 Data fetching \u2705 \u2705 UI state management \u274c Use Context or Hooks \u2705 Performance optimization \u2705 \u2705"},{"location":"miscellaneous/hoc/naming-convention/","title":"Naming Convention","text":""},{"location":"miscellaneous/hoc/naming-convention/#naming-conventions-for-hocs-and-hooks-in-react","title":"\u2705 Naming Conventions for HOCs and Hooks in React","text":"<p>When working with HOCs and custom hooks, it's important to follow consistent naming conventions to improve code readability and maintainability.</p>"},{"location":"miscellaneous/hoc/naming-convention/#naming-conventions-for-higher-order-components-hocs","title":"\ud83d\udcc4 Naming Conventions for Higher-Order Components (HOCs)","text":"<p>\u2705 Filename:</p> <ul> <li>Start the filename <code>with</code> with to indicate it's a HOC.</li> </ul> <p>\u2705 Example:</p> Component Purpose Filename Authorization HOC <code>withAuthorization.js</code> Logging HOC <code>withLogging.js</code> Data Fetching HOC <code>withDataFetching.js</code> <p>\u2705 Function Name:</p> <ul> <li>Use the same name as the file for consistency.</li> </ul> <pre><code>// File: withAuthorization.js\nconst withAuthorization = (WrappedComponent) =&gt; {\n  return (props) =&gt; {\n    const isAuthenticated = localStorage.getItem(\"token\");\n    return isAuthenticated ? (\n      &lt;WrappedComponent {...props} /&gt;\n    ) : (\n      &lt;h1&gt;Access Denied&lt;/h1&gt;\n    );\n  };\n};\n\nexport default withAuthorization;\n</code></pre>"},{"location":"miscellaneous/hoc/naming-convention/#naming-conventions-for-custom-hooks","title":"\ud83d\udcc4 Naming Conventions for Custom Hooks","text":"<p>\u2705 Filename:</p> <ul> <li>Start the filename with <code>use</code> to indicate it's a hook.</li> </ul> <p>\u2705 Example:</p> Hook Purpose Filename Data Fetching Hook <code>useFetchData.js</code> Authentication Hook <code>useAuth.js</code> Debounce Hook <code>useDebounce.js</code> <p>\u2705 Function Name:</p> <ul> <li>Use the same name as the file for consistency.</li> </ul> <pre><code>// File: useFetchData.js\nimport { useState, useEffect } from \"react\";\n\nconst useFetchData = (url) =&gt; {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() =&gt; {\n    fetch(url)\n      .then((response) =&gt; response.json())\n      .then((data) =&gt; {\n        setData(data);\n        setLoading(false);\n      });\n  }, [url]);\n\n  return { data, loading };\n};\n\nexport default useFetchData;\n</code></pre>"},{"location":"miscellaneous/hoc/naming-convention/#quick-summary-of-naming","title":"\ud83d\udcdd Quick Summary of Naming:","text":""},{"location":"miscellaneous/hoc/naming-convention/#pro-tip","title":"\ud83d\udd25 Pro Tip:","text":"<p>Keep your HOCs inside a <code>hoc</code> folder and your hooks inside a <code>hooks</code> folder for better structure.</p> <pre><code>\ud83d\udcc2 src\n \u2523 \ud83d\udcc2 hoc\n \u2503 \u2523 \ud83d\udcc4 withAuthorization.js\n \u2503 \u2523 \ud83d\udcc4 withLogging.js\n \u2517 \ud83d\udcc2 hooks\n   \u2523 \ud83d\udcc4 useFetchData.js\n   \u2523 \ud83d\udcc4 useAuth.js\n</code></pre>"},{"location":"miscellaneous/push-notifications/best-practices/","title":"Best Practices","text":"<p>d</p>"},{"location":"miscellaneous/push-notifications/examples/","title":"Example","text":"<p>s</p>"},{"location":"miscellaneous/push-notifications/introduction/","title":"Introduction","text":"<p>Intro</p>"},{"location":"miscellaneous/push-notifications/introduction/#reference","title":"Reference","text":"<ul> <li>Medium: Real-Time Notifications in React: Types and Implementations</li> <li>Stackoverflow: Websockets vs. iOS Push Notifications</li> <li>Forum: WebSockets vs Push Notifications (AWS Pinpoint)</li> <li>Reddit: SSE or Websockets for push notifications? </li> </ul>"},{"location":"miscellaneous/push-notifications/setup/","title":"Setup","text":"<p>s</p>"},{"location":"miscellaneous/websockets/examples/","title":"Example","text":"<ul> <li>SignalR: Best for real-time communication (two-way communication) between clients and server.</li> <li>Push Notifications: Best for one-way alerts to users even when they are not actively interacting with the app.</li> </ul> <p>SignalR Example: A real-time chat app where users can send and receive messages instantly without refreshing the page. You might want to use SignalR to broadcast messages as they come in.</p> <p>Push Notifications Example: A notification when a user receives a new email, even if they are not actively on the app or the browser. This requires setting up push notifications with service workers.</p> <p>No, @microsoft/signalr and push notifications are not the same in React, though both can be used to achieve real-time communication.</p>"},{"location":"miscellaneous/websockets/introduction/","title":"Introduction","text":"<p>Introduction</p> <p></p>"},{"location":"miscellaneous/websockets/introduction/#reference","title":"Reference","text":"<ul> <li>Stackoverflow: React JS socket.io-client opens multiple connections</li> <li>Blog: Real-time notifications with React and Socket-IO</li> <li>Blog: The complete guide to WebSockets with React</li> <li>Blog: How to Integrate Socket.IO in ReactJS \u2013 Quick Guide for Beginners</li> <li>Blog: How to Integrate WebSockets into React Apps?</li> <li>Blog: Unlocking how Socket.io can boost your React app's real-time capabilities </li> <li>Blog: Create a Secure Chat Application with Socket.IO and React</li> <li>Blog: Push Notifications and Web Sockets in React Native </li> <li>Image: The Basics of WebSockets</li> <li>Package: @microsoft/signalr</li> </ul>"},{"location":"miscellaneous/websockets/setup/","title":"Setup","text":"<p>s</p>"},{"location":"miscellaneous/websockets/troubleshooting/","title":"Troubleshooting","text":""},{"location":"miscellaneous/websockets/troubleshooting/#react-memo","title":"React Memo","text":"<ol> <li> <p>Usage of <code>React.memo</code>:</p> <p>You are correctly using <code>React.memo</code> around the PasswordReset component:</p> <pre><code>const PasswordReset = React.memo(({ form, id, visible, onClose }) =&gt; { ... });\n</code></pre> <p><code>React.memo</code> is a higher-order component (HOC) that memoizes the component, which prevents unnecessary re-renders. It ensures that <code>PasswordReset</code> only re-renders if its props (<code>form</code>, <code>id</code>, <code>visible</code>, <code>onClose</code>) change.</p> Correct Usage: <ul> <li><code>form</code>, <code>id</code>, <code>visible</code>, and <code>onClose</code> are all props being passed to <code>PasswordReset</code>.</li> <li>If these props don't change, <code>React.memo</code> will prevent re-renders and optimize performance by skipping them.</li> </ul> </li> <li> <p>Understanding When React.memo Works:</p> <p><code>React.memo</code> performs a shallow comparison of the props passed to the component. This means that if any prop is a complex object (e.g., an array or an object) and it changes reference, <code>React.memo</code> will trigger a re-render even if the object's contents haven't changed.</p> In your case: <ul> <li><code>form</code>: If the form object is passed down and is a complex object (e.g., an <code>antd</code> form instance), it might change on every render, causing unnecessary re-renders even with <code>React.memo</code>. If you notice unnecessary re-renders in such cases, consider memoizing or stabilizing the form instance itself.</li> <li><code>id</code>, <code>visible</code>, and <code>onClose</code>: These are simple values (strings, booleans, or functions), so <code>React.memo</code> will work efficiently here as long as the values don\u2019t change on each render.</li> </ul> </li> </ol> Things to Keep in Mind <ol> <li> <p>Memoization:</p> <ul> <li>Ensure that the props passed to the memoized component (<code>form</code>, <code>id</code>, etc.) don\u2019t change unnecessarily. For example, if form is re-created on every render of the parent component (<code>Users.jsx</code>), <code>React.memo</code> won\u2019t prevent a re-render because it will always see a new reference for form.</li> <li>If you're using the <code>antd</code> <code>Form</code> component, keep in mind that instances of forms tend to change references frequently, which can cause re-renders despite <code>React.memo</code>. If that's the case, you may need to consider memoizing or using a stable reference for the form instance.</li> </ul> </li> <li> <p>Functional Updates:</p> <ul> <li>If you're passing functions like <code>onClose</code> and <code>handleClosePasswordDrawer</code> as props, make sure they aren't re-created on each render of the parent (<code>Users.jsx</code>). If these functions are defined inline (e.g., inside the parent component), it could cause re-renders as <code>React.memo</code> will see a new function reference each time.</li> </ul> </li> </ol> <p>You could define the functions outside the render method or use <code>useCallback</code> to prevent unnecessary recreation.</p> <p>Conclusion:</p> <p>Your usage of <code>React.memo</code> is correct in general, but here are some recommendations:</p> <ul> <li>Make sure the props passed to the memoized component don't change frequently (especially complex objects like <code>form</code>).</li> <li>For side effects (like logging), use <code>useEffect</code> to handle them efficiently.</li> <li>Consider using <code>useCallback</code> or <code>useMemo</code> in the parent component to avoid unnecessary re-creations of <code>functions</code> and <code>objects</code> passed as props.</li> </ul>"},{"location":"miscellaneous/websockets/troubleshooting/#memo","title":"Memo","text":"<p>what are the differents ways to use <code>React.memo</code>;</p> <ol> <li><code>const PasswordReset = React.memo(({ id, visible, onClose }) =&gt; {});</code></li> <li><code>export default memo(Todos);</code></li> </ol>"},{"location":"miscellaneous/websockets/troubleshooting/#reference","title":"Reference","text":"<ul> <li>Blog: Understanding useMemo and useCallback</li> <li>Blog: What is React memo and how to use it?</li> <li>Blog: React useMemo Hook Guide with Examples</li> <li>Blog: Optimize React Render using useMemo, useCallback, and React.memo</li> <li>How to Work with useMemo in React \u2013 with Code Examples</li> </ul>"},{"location":"nextjs/api-routes/","title":"\ud83d\udee0 API Routes in Next.js","text":"<p>Next.js allows you to create serverless API routes using file-based routing.</p>"},{"location":"nextjs/api-routes/#api-routes-in-app-router","title":"\ud83d\udcc2 API Routes in App Router","text":"<p>In the App Router, API routes are defined inside the <code>app/api/</code> folder.</p> <p>Example:</p> <pre><code>app/api/\n\u251c\u2500\u2500 hello/\n\u2502   \u2514\u2500\u2500 route.ts    # API Route: /api/hello\npages/api/\n\u251c\u2500\u2500 hello.js        # API Route: /api/hello\n</code></pre>"},{"location":"nextjs/api-routes/#in-the-pages-router-api-routes-are-defined-inside-the-pagesapi-folder","title":"In the Pages Router, API routes are defined inside the pages/api/ folder.","text":"<pre><code>pages/api/\n\u251c\u2500\u2500 hello.js        # API Route: /api/hello\n</code></pre> <p>\ud83d\udccb Example API Route (Pages Router)</p> <pre><code>// pages/api/hello.js\nexport default function handler(req, res) {\n  res.status(200).json({ message: \"Hello, Next.js!\" });\n}\n</code></pre>"},{"location":"nextjs/data-fetching/","title":"\ud83d\udce1 Data Fetching in Next.js","text":"<p>Next.js supports various data-fetching strategies:</p> <ol> <li>Server-Side Rendering (SSR)</li> <li>Static Site Generation (SSG)</li> <li>Incremental Static Regeneration (ISR)</li> <li>Client-Side Fetching</li> </ol>"},{"location":"nextjs/data-fetching/#example-server-side-rendering-ssr","title":"\ud83d\udccb Example: Server-Side Rendering (SSR)","text":"<pre><code>// app/page.tsx\nexport async function getServerSideProps() {\n  const data = await fetch(\"https://api.example.com/data\");\n  return { props: { data } };\n}\n</code></pre>"},{"location":"nextjs/data-fetching/#quick-recap-rendering-methods","title":"\ud83d\udce6 Quick Recap: Rendering Methods","text":"Method Who Builds the Page? When Is It Built? Where? CSR (Client-Side Rendering) The browser (client) After user loads the page On the user's device SSR (Server-Side Rendering) The server Every time a user requests the page On the server SSG (Static Site Generation) The build tool At build time (before deployment) Ahead of time ISR (Incremental Static Regeneration) The server (on demand) After build, but only sometimes On the server"},{"location":"nextjs/data-fetching/#summary-table","title":"\ud83e\udded Summary Table","text":"Rendering Type Who Builds It? When Use Case Example CSR Browser (client) After load SPAs (like dashboards) A web-based email client like Gmail, admin dashboards SSR Server On every request Dynamic, SEO-friendly pages A news site like BBC, where content changes often SSG Build step At deploy time Blogs, marketing sites A personal blog or portfolio website ISR Server (on request) After deploy, per page Product pages, hybrid sites An e-commerce site like Amazon product pages"},{"location":"nextjs/data-fetching/#what-about-nextjs","title":"\u269b\ufe0f What About Next.js?","text":"<p>Next.js supports all these rendering types:</p> Feature Next.js Support? How to Use CSR \u2705 Yes Use dynamic imports or client components SSR \u2705 Yes Use <code>getServerSideProps()</code> SSG \u2705 Yes Use <code>getStaticProps()</code> + <code>getStaticPaths()</code> ISR \u2705 Yes Use <code>revalidate</code> option in <code>getStaticProps()</code>"},{"location":"nextjs/data-fetching/#which-one-should-you-use","title":"\ud83e\udde0 Which One Should You Use?","text":"Site Type Best Option Blog / Docs SSG or ISR News / Stock / Weather SSR Dashboard / Internal Tool CSR E-commerce ISR (for product pages), SSR (for checkout)"},{"location":"nextjs/data-fetching/#final-takeaway","title":"\u2705 Final Takeaway","text":"<p>Think of it like this:</p> <ul> <li>\ud83d\udd25 SSG = Build once, serve instantly</li> <li>\ud83d\udd04 ISR = Build once, update smartly</li> <li>\ud83d\udce1 SSR = Build fresh every time</li> <li>\ud83e\udde0 CSR = Let the browser do the work</li> </ul>"},{"location":"nextjs/data-fetching/#explanation","title":"Explanation","text":"<p>Let me explain CSR (Client-Side Rendering) and SSR (Server-Side Rendering) in layman's terms, using a simple analogy.</p> <p>\ud83c\udfe0 Imagine a Restaurant</p> <p>\ud83c\udf7d You go to a restaurant and order food.</p> <p>Now, there are two ways the restaurant can serve you:</p>"},{"location":"nextjs/data-fetching/#ssr-server-side-rendering-chef-cooks-in-the-kitchen","title":"\ud83e\uddd1\u200d\ud83c\udf73 SSR \u2014 Server-Side Rendering (Chef cooks in the kitchen)","text":"<ul> <li>You order your food.</li> <li>The chef prepares the entire dish in the kitchen.</li> <li>When it\u2019s ready, they bring you the full, hot meal.</li> <li>You just sit and eat \u2014 everything is done before it gets to your table.</li> </ul> <p>\ud83d\udfe2 Pros:</p> <ul> <li>Fast first bite: You get a fully prepared meal quickly.</li> <li>Good for SEO (search engines can see the full dish).</li> </ul> <p>\ud83d\udd34 Cons:</p> <ul> <li>If you want something else (e.g., dessert), the waiter must go back, talk to the chef, cook, and bring it again.</li> </ul>"},{"location":"nextjs/data-fetching/#csr-client-side-rendering-diy-table-cooking","title":"\ud83e\uddd1\u200d\ud83c\udf73 CSR \u2014 Client-Side Rendering (DIY table cooking)","text":"<ul> <li>You walk in, and the restaurant gives you raw ingredients and a hot plate.</li> <li>The chef doesn\u2019t cook; you cook at your table.</li> <li>It takes a while to get started, but once your tools are ready, you can make more dishes without waiting.</li> </ul> <p>\ud83d\udfe2 Pros:</p> <ul> <li>Smooth, fast experience after initial load.</li> <li>Great for dynamic apps (like dashboards or social media).</li> </ul> <p>\ud83d\udd34 Cons:</p> <ul> <li>Slow to start: You have to do the cooking.</li> <li>Not great for SEO \u2014 search engines might see an empty plate.</li> </ul> <p>\ud83c\udf54 Translating to Websites</p> Term What It Means SSR (Server-Side Rendering) The server builds the full HTML page and sends it to the browser. It\u2019s like the chef doing all the cooking and sending the full plate. CSR (Client-Side Rendering) The browser gets a mostly empty page + JavaScript, and builds everything on your device. You do the cooking. <p>\ud83d\udc40 Real-World Examples</p> Website Type Usually Uses News sites, blogs, e-commerce (SEO matters) SSR or Static Rendering Web apps like Gmail, Facebook, dashboards CSR <p>\ud83d\udca1 Summary</p> Feature CSR SSR First load Slower Faster SEO friendly \u274c No \u2705 Yes Dynamic content \u2705 Great \u26a0\ufe0f Needs refresh Server load Low High User experience Smooth after load Fast at first"},{"location":"nextjs/data-fetching/#ssg-static-site-generation","title":"\ud83e\udd57 SSG (Static Site Generation)","text":"<p>\"Pre-made meals in the fridge\"</p> <ul> <li>The chef cooks all the meals in the morning, before any customers arrive.</li> <li>When a customer comes, you instantly serve the dish from the fridge.</li> <li>It\u2019s fast and easy \u2014 no cooking, no waiting.</li> <li>But... if the menu changes, you must rebuild everything.</li> </ul> <p>.</p> <ul> <li>\u2705 Super fast for the user</li> <li>\u274c Not ideal for content that changes often</li> </ul>"},{"location":"nextjs/data-fetching/#isr-incremental-static-regeneration","title":"\ud83c\udf71 ISR (Incremental Static Regeneration)","text":"<p>\"Pre-made meals that get refreshed quietly\"</p> <p>Meals are still pre-made, but if someone asks for an old dish, the restaurant will:</p> <ul> <li>Serve the old version instantly</li> <li>\ud83d\udd04 Silently refresh it in the background, so the next customer gets a fresh one</li> </ul> <p>.</p> <ul> <li>\u2705 Fast AND up-to-date</li> <li>\u2705 Great for blogs, products, etc.</li> <li>\u26a0\ufe0f Needs a framework that supports it (e.g., Next.js)</li> </ul>"},{"location":"nextjs/deployment/","title":"\ud83d\ude80 Deploying Next.js Apps","text":"<p>You can deploy Next.js apps to Vercel (recommended), Netlify, or other platforms.</p>"},{"location":"nextjs/deployment/#deploy-to-vercel","title":"\u2705 Deploy to Vercel","text":"<pre><code>vercel deploy\n</code></pre>"},{"location":"nextjs/deployment/#deploy-to-netlify","title":"\u2705 Deploy to Netlify","text":"<pre><code>netlify deploy\n</code></pre>"},{"location":"nextjs/deployment/#deploy-with-docker","title":"\u2705 Deploy with Docker","text":"Create a Dockerfile<pre><code># Dockerfile\nFROM node:alpine\nWORKDIR /app\nCOPY . .\nRUN npm install\nRUN npm run build\nEXPOSE 3000\nCMD [\"npm\", \"start\"]\n</code></pre>"},{"location":"nextjs/folder-structure/","title":"\ud83d\udcc2 Next.js Folder Structure","text":"<p>A standard Next.js project follows this folder structure:</p> <pre><code>my-next-app/\n\u251c\u2500\u2500 .next/              # Build output (generated after build)\n\u251c\u2500\u2500 app/                # App Router (Next.js 13+)\n\u2502   \u251c\u2500\u2500 layout.tsx      # Root layout\n\u2502   \u2514\u2500\u2500 page.tsx        # Root page\n\u251c\u2500\u2500 pages/              # Pages Router (Legacy)\n\u2502   \u2514\u2500\u2500 index.js        # Homepage\n\u251c\u2500\u2500 components/         # Reusable components\n\u251c\u2500\u2500 public/             # Static files (images, fonts, etc.)\n\u251c\u2500\u2500 styles/             # Global CSS files\n\u251c\u2500\u2500 next.config.js      # Next.js configuration\n\u251c\u2500\u2500 package.json        # Project dependencies\n\u2514\u2500\u2500 README.md           # Project documentation\n</code></pre> <p>\ud83d\udccc Key Folders</p> <ul> <li><code>app/</code>: New App Router for routes and layouts.</li> <li><code>pages/</code>: Legacy Pages Router for defining routes.</li> <li><code>public/</code>: Static assets like images, fonts, and files.</li> </ul>"},{"location":"nextjs/folder-structure/#folder-structure-comparison","title":"\ud83d\udee0 Folder Structure Comparison","text":"Feature App Router Pages Router Routing File-based File-based Layouts Nested layouts No nested layouts Server Components Supported Not supported Data Fetching Methods SSG, SSR, ISR SSG, SSR API Routes <code>/app/api/</code> folder <code>/pages/api/</code> folder Folder Structure\ud83d\udd39 Key Directories Explained <pre><code>my-nextjs-app/\n\u2502\u2500\u2500 public/                # Static assets (images, fonts, etc.)\n\u2502\u2500\u2500 src/                   # Source code (optional, recommended)\n\u2502   \u251c\u2500\u2500 app/               # App Router (used in Next.js 13+ with \"app directory\")\n\u2502   \u2502   \u251c\u2500\u2500 layout.tsx     # Root layout for the app (persists across pages)\n\u2502   \u2502   \u251c\u2500\u2500 page.tsx       # The main page (route: \"/\")\n\u2502   \u2502   \u251c\u2500\u2500 dashboard/     # Nested route example (\"/dashboard\")\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 page.tsx   # Page inside dashboard route\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 layout.tsx # Layout for dashboard pages\n\u2502   \u2502   \u251c\u2500\u2500 api/           # API routes (server actions)\n\u2502   \u251c\u2500\u2500 components/        # Reusable UI components\n\u2502   \u251c\u2500\u2500 hooks/             # Custom React hooks\n\u2502   \u251c\u2500\u2500 lib/               # Utility functions and helper methods\n\u2502   \u251c\u2500\u2500 styles/            # Global styles (CSS, SCSS, Tailwind)\n\u2502   \u251c\u2500\u2500 store/             # State management (Zustand, Redux, etc.)\n\u2502\u2500\u2500 pages/                 # (Legacy) Pages Router (Used before Next.js 13)\n\u2502\u2500\u2500 .next/                 # Build output (generated after running `next build`)\n\u2502\u2500\u2500 node_modules/          # Installed dependencies\n\u2502\u2500\u2500 .env                   # Environment variables\n\u2502\u2500\u2500 next.config.js         # Next.js configuration file\n\u2502\u2500\u2500 package.json           # Project dependencies and scripts\n\u2502\u2500\u2500 tsconfig.json          # TypeScript configuration (if using TypeScript)\n\u2502\u2500\u2500 README.md              # Project documentation\n</code></pre> <ul> <li><code>public/</code> \u2192 Stores static assets (images, favicons, etc.)</li> <li><code>src/app/</code> \u2192 Used for App Router (<code>app directory</code>) if using Next.js 13+</li> <li><code>pages/</code> \u2192 (Legacy) Used for Pages Router (before Next.js 13)</li> <li><code>components/</code> \u2192 Stores reusable UI components</li> <li><code>lib/</code> \u2192 Common utility functions (API calls, helpers)</li> <li><code>store/</code> \u2192 State management (Redux, Zustand, etc.)</li> <li><code>hooks/</code> \u2192 Custom React hooks</li> <li><code>styles/</code> \u2192 Global styles (CSS, Tailwind, etc.)</li> <li><code>api/</code> \u2192 API routes (if using App Router)</li> </ul> <p>Since you are working with React &amp; Redux Toolkit, you might organize Redux slices inside <code>store/</code>.</p> <p>Would you like a structure tailored to your feature-based approach? \ud83d\ude80</p> <p>Since you follow a feature-based approach, here's a Next.js project structure optimized for modularity with Redux Toolkit (RTK) and your preferred setup:</p> <pre><code>my-nextjs-app/\n\u2502\u2500\u2500 public/                # Static assets (images, fonts, etc.)\n\u2502\u2500\u2500 src/                   # Source code (recommended structure)\n\u2502   \u251c\u2500\u2500 app/               # App Router (Next.js 13+)\n\u2502   \u2502   \u251c\u2500\u2500 layout.tsx     # Root layout (persists across pages)\n\u2502   \u2502   \u251c\u2500\u2500 page.tsx       # Home page (\"/\")\n\u2502   \u2502   \u251c\u2500\u2500 dashboard/     # Example nested route (\"/dashboard\")\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 page.tsx   # Dashboard page\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 layout.tsx # Layout for dashboard pages\n\u2502   \u2502   \u251c\u2500\u2500 api/           # API routes (if needed)\n\u2502   \u251c\u2500\u2500 features/          # Feature-based approach\n\u2502   \u2502   \u251c\u2500\u2500 auth/          # Authentication feature\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 components/LoginForm.tsx\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 hooks/useAuth.ts\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 services/authService.ts\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 store/authSlice.ts\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 types.ts   # TypeScript types (if using TS)\n\u2502   \u2502   \u251c\u2500\u2500 assignments/   # Example: Assignments feature\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 components/AssignmentCard.tsx\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 store/assignmentSlice.ts\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 services/assignmentAPI.ts\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 hooks/useAssignments.ts\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 types.ts\n\u2502   \u251c\u2500\u2500 shared/            # Shared utilities and resources\n\u2502   \u2502   \u251c\u2500\u2500 components/    # Reusable UI components\n\u2502   \u2502   \u251c\u2500\u2500 hooks/         # Custom React hooks\n\u2502   \u2502   \u251c\u2500\u2500 layouts/       # Shared layouts (e.g., Sidebar, Header)\n\u2502   \u2502   \u251c\u2500\u2500 services/      # Global API services\n\u2502   \u2502   \u251c\u2500\u2500 utils/         # Helper functions\n\u2502   \u2502   \u251c\u2500\u2500 store/         # Global Redux store\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 store.ts   # Redux store configuration\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 rootReducer.ts # Combine reducers\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 middlewares.ts  # Custom middlewares (if needed)\n\u2502   \u251c\u2500\u2500 styles/            # Global styles (CSS/Tailwind)\n\u2502\u2500\u2500 .next/                 # Build output\n\u2502\u2500\u2500 node_modules/          # Installed dependencies\n\u2502\u2500\u2500 .env                   # Environment variables\n\u2502\u2500\u2500 next.config.js         # Next.js configuration\n\u2502\u2500\u2500 package.json           # Project dependencies\n\u2502\u2500\u2500 tsconfig.json          # TypeScript configuration\n\u2502\u2500\u2500 README.md              # Project documentation\n</code></pre> <p>\ud83d\ude80 Key Improvements for Your Setup</p> <ul> <li>\u2705 Feature-Based Structure \u2192 Each feature (e.g., <code>auth</code>, <code>assignments</code>) has its own <code>components</code>, <code>hooks</code>, <code>store</code>, and <code>services</code>.</li> <li>\u2705 Centralized Shared Folder \u2192 Common resources like <code>utils</code>, <code>hooks</code>, <code>layouts</code>, and <code>components</code> stay in <code>shared/</code>.</li> <li>\u2705 Redux Toolkit Store Inside <code>shared/store/</code> \u2192 Keeps slices modular but still centrally managed.</li> <li>\u2705 TypeScript-Ready (<code>types.ts</code> per feature) \u2192 Easy type sharing if you use TypeScript later.</li> </ul>"},{"location":"nextjs/folder-structure/#project-structure","title":"Project Structure","text":"<p>Next.js project structure is based on routing system. The routing system in Next.js is file-based, which means the file structure inside the <code>pages/</code> or <code>app/</code> directory determines the application routes automatically.</p>"},{"location":"nextjs/folder-structure/#folder-and-file-conventions","title":"Folder and file conventions","text":""},{"location":"nextjs/folder-structure/#top-level-folders","title":"Top-level folders","text":"<p>Top-level folders are used to organize your application's code and static assets.</p> Method Description <code>app</code> App Router <code>pages</code> Pages Router <code>public</code> Static assets to be served <code>src</code> Optional application source folder"},{"location":"nextjs/folder-structure/#top-level-files","title":"Top-level files","text":"<p>Top-level files are used to configure your application, manage dependencies, run middleware, integrate monitoring tools, and define environment variables.</p> Next.js Description <code>next.config.js</code> Configuration file for Next.js <code>package.json</code> Project dependencies and scripts <code>instrumentation.ts</code> OpenTelemetry and Instrumentation file <code>middleware.ts</code> Next.js request middleware"},{"location":"nextjs/folder-structure/#reference","title":"Reference","text":"<ul> <li>Project Structure</li> </ul>"},{"location":"nextjs/intro/","title":"Next.js Documentation","text":"<p>Welcome to the Next.js Documentation!</p> <p>Next.js is a React framework that enables server-side rendering (SSR), static site generation (SSG), API routes, and more.</p>"},{"location":"nextjs/intro/#key-features-of-nextjs","title":"\ud83d\ude80 Key Features of Next.js","text":"<ul> <li>File-based routing</li> <li>Server-side rendering (SSR)</li> <li>Static site generation (SSG)</li> <li>API routes</li> <li>Image optimization</li> <li>Built-in CSS and Sass support</li> <li>Fast performance and SEO-friendly</li> </ul>"},{"location":"nextjs/intro/#what-youll-learn","title":"\ud83d\udcda What You'll Learn","text":"<ol> <li>Folder Structure</li> <li>Routing</li> <li>API Routes</li> <li>Data Fetching</li> <li>Deployment</li> <li>Configuration</li> </ol>"},{"location":"nextjs/intro/#built-in-utilitiescomponents","title":"Built-in Utilities/Components","text":"<ul> <li> <p>Routing &amp; Navigation</p> <ul> <li><code>next/link</code></li> <li><code>next/router</code></li> </ul> </li> <li> <p>SEO &amp; Head Management</p> <ul> <li><code>next/head</code></li> </ul> </li> <li> <p>Image Optimization</p> <ul> <li><code>next/image</code></li> </ul> </li> <li> <p>Script &amp; External Resources:</p> <ul> <li><code>next/script</code></li> </ul> </li> <li> <p>Dynamic Imports &amp; Code Splitting</p> <ul> <li><code>next/dynamic</code></li> </ul> </li> <li> <p>Error Handling:</p> <ul> <li><code>next/error</code></li> </ul> </li> <li> <p>AMP (Accelerated Mobile Pages)</p> <ul> <li><code>next/amp</code></li> </ul> </li> <li> <p>Analytics (Optional, for tracking visits)</p> <ul> <li><code>next/analytics</code></li> </ul> </li> </ul>"},{"location":"nextjs/next-config/","title":"\u2699\ufe0f next.config.js Configuration","text":"<p>The <code>next.config.js</code> file allows you to configure your Next.js app.</p>"},{"location":"nextjs/next-config/#example-configuration","title":"\ud83d\udccb Example Configuration","text":"<pre><code>// next.config.js\nconst nextConfig = {\n  reactStrictMode: true,\n  images: {\n    domains: [\"example.com\"],\n  },\n};\n\nmodule.exports = nextConfig;\n</code></pre>"},{"location":"nextjs/routing/","title":"\ud83c\udf10 Routing in Next.js","text":"<p>Next.js uses file-based routing, where the file structure inside the <code>pages/</code> or <code>app/</code> folder determines the routes.</p>"},{"location":"nextjs/routing/#app-router-new-in-nextjs-13","title":"\ud83d\uddc2 App Router (New in Next.js 13+)","text":"<p>In the App Router, routes are defined inside the <code>app/</code> folder.</p> <p>Example:</p> <pre><code>app/\n\u251c\u2500\u2500 page.tsx        # Route: /\n\u251c\u2500\u2500 about/\n\u2502   \u2514\u2500\u2500 page.tsx    # Route: /about\n\u2514\u2500\u2500 dashboard/\n    \u2514\u2500\u2500 page.tsx    # Route: /dashboard\npages/\n\u251c\u2500\u2500 index.js        # Route: /\n\u251c\u2500\u2500 about.js        # Route: /about\n\u2514\u2500\u2500 dashboard.js    # Route: /dashboard\n</code></pre>"},{"location":"nextjs/routing/#types-of-routing-in-nextjs","title":"Types of Routing in Next.JS","text":"<p>You will asked to choose type of routing for your Next.js project, while creating a new project. Following are routes used in Next.js</p> <ul> <li>Page Routing</li> <li>App Routing</li> </ul>"},{"location":"nextjs/routing/#router","title":"Router","text":"<p>In Next.js, App Router and Page Router refer to two different routing systems used for handling navigation within your application. Each one has its own use case, and whether you need to use both depends on the version of Next.js you're working with and your specific project needs.</p> <p>Page Router (Traditional Approach)</p> <ul> <li> <p>Used in Next.js 12 and earlier (before the App Router was introduced).</p> </li> <li> <p>In this approach, routing is handled by creating files inside the pages directory. Each file automatically becomes a route in the app.</p> </li> <li> <p>Example:</p> <ul> <li><code>pages/index.js</code> \u2192 <code>/</code></li> <li><code>pages/about.js</code> \u2192 <code>/about</code></li> </ul> </li> </ul> <p>You don\u2019t need to explicitly configure routing or map paths to components; Next.js does it automatically based on the file structure.</p> <p>App Router (Introduced in Next.js 13)</p> <ul> <li>Introduced in Next.js 13 as part of the new app directory.</li> <li>The App Router uses a new file system structure where routes are created inside the <code>app</code> directory.</li> <li>The new router is more flexible and provides a more structured way to organize your app, supporting layouts, templates, nested routes, error boundaries, and server-side data fetching in a more intuitive way.</li> <li> <p>Example:</p> <ul> <li><code>app/page.js</code> \u2192 <code>/</code></li> <li><code>app/about/page.js</code> \u2192 <code>/about</code></li> <li><code>app/products/[id]/page.js</code> \u2192 <code>/products/:id</code></li> </ul> </li> </ul> <p>The App Router offers additional features like server-side rendering for pages by default and the ability to create shared layouts and templates.</p> Do You Need Both? <ul> <li> <p>No, you don\u2019t need to use both. You can choose either the Page Router (using the <code>pages</code> directory) or the App Router (using the <code>app</code> directory).</p> </li> <li> <p>Standard approach depends on the Next.js version you are using:</p> <ul> <li> <p>If you're using Next.js 13 or later, it's recommended to use the App Router, as it offers more features and better support for modern React paradigms like Server Components.</p> </li> <li> <p>Page Router is still supported and works fine for simpler projects or for those who prefer the more traditional file-based routing approach.</p> </li> </ul> </li> </ul>"},{"location":"nextjs/routing/#summary-of-the-differences","title":"Summary of the Differences","text":"Feature Page Router (<code>pages/</code>) App Router (<code>app/</code>) File Location <code>pages/</code> <code>app/</code> Supported in Next.js 12 and below Next.js 13+ Routing Type File-based routing File-based + dynamic routing, layouts, templates SSR Support Yes Yes Data Fetching Can be done via API routes Built-in support for SSR, async loading, etc. Layout Support Limited Full support for layouts, templates, etc."},{"location":"nextjs/routing/#which-one-should-you-use","title":"Which One Should You Use?","text":"<ul> <li>If you\u2019re starting a new project with Next.js 13 or later, App Router is generally the recommended approach.</li> <li>If you're working on an existing project with the Page Router or prefer its simplicity, you can stick with that.</li> </ul> <ul> <li>Tutorial Point, Next.js - Routing</li> </ul>"},{"location":"nextjs/theory/","title":"Intro","text":""},{"location":"nextjs/theory/#built-in-routing","title":"Built-in Routing","text":"<p>Next.js provides built-in routing that makes it easy to create dynamic and complex websites with multiple pages.</p> <p>Here are some of the key features of Next.js routing.</p>"},{"location":"nextjs/theory/#file-based-routing","title":"File-based Routing","text":"<p>Let's say you have a website with the following pages:</p> <ul> <li>Home</li> <li>About</li> <li>Services</li> <li>Contact</li> </ul> <p>To create these pages in Next.js, you would create the following files in the pages directory:</p> <pre><code>pages/\n\u251c\u2500\u2500 index.js\n\u251c\u2500\u2500 about.js\n\u251c\u2500\u2500 services.js\n</code></pre> <p>The <code>index.js</code> file corresponds to the homepage of your website, and the other files correspond to the other pages. For example, the <code>about.js</code> file would contain the code for the About page, the <code>services.js</code> file would contain the code for the Services page, and so on.</p> pages/about.js<pre><code>function AboutPage() {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;About Us&lt;/h1&gt;\n      &lt;p&gt;\n        We are a company that specializes in creating high-quality websites.\n      &lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\nexport default AboutPage;\n</code></pre> <p>In this example, we've created a simple About page component that contains a heading and some text. When a user visits the <code>/about</code> route on our website, Next.js will automatically render this component and serve it as an HTML response to the user's browser.</p>"},{"location":"nextjs/theory/#dynamic-routes","title":"Dynamic Routes","text":""},{"location":"nextjs/theory/#nested-routes","title":"Nested Routes","text":""},{"location":"nextjs/theory/#api-routes","title":"API Routes","text":"<p>Next.js also allows you to create API routes, which can be used to fetch data from your backend or third-party APIs.</p> <p>API routes are similar to regular routes, but instead of returning HTML, they return data in JSON format. This makes it easy to create powerful and exible APIs that can be used by your front end or other applications.</p> <p>Let's say you have a backend API that returns a list of products in JSON format. You want to create a front-end page that displays this list of products using Next.js. To do this, you can create an API route in</p> <p>Next.js that fetches the data from your backend API and returns it in JSON format.</p> <p>To create an API route in Next.js, you would create a file in the <code>pages/api</code> directory.</p> <pre><code>pages/\n\u2514\u2500\u2500 api\n\u2514\u2500\u2500 products.js\n</code></pre> pages/api/products.js<pre><code>export default async function handler(req, res) {\n  const response = await fetch(\"https://an-external-api.com/products\");\n  const products = await response.json();\n}\nres.status(200).json(products);\n</code></pre> <p>In this example, we're using the built-in fetch function to fetch the list of products from our backend API, and then return the list of products in JSON format using the <code>res.json()</code> method.</p> <p>Now, we can use this API route to fetch the list of products from our front-end page. Here's an example of what the front-end page might look like:</p> <pre><code>import { useState, useEffect } from \"react\";\nfunction ProductList() {\n  const [products, setProducts] = useState([]);\n  useEffect(async () =&gt; {\n    const response = await fetch(\"/api/products\");\n    const products = await response.json();\n    setProducts(products);\n  }, []);\n}\nreturn (\n  &lt;div&gt;\n    &lt;h1&gt;Product List&lt;/h1&gt;\n    &lt;ul&gt;\n      {products.map((product) =&gt; (\n        &lt;li key={product.id}&gt;{product.name}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  &lt;/div&gt;\n);\nexport default ProductList;\n</code></pre> <p>In this example, we're using the built-in fetch function to fetch the list of products from our API route, and then using the <code>useState</code> and <code>useEffect</code> hooks to update the component state with the list of products.</p> <p>Now, when a user visits this page, Next.js will automatically fetch the list of products from the API route and display it on the page.</p>"},{"location":"nextjs/theory/#link-component","title":"Link Component","text":"<p>Next.js provides a <code>Link</code> component that makes it easy to create links between pages on your website. This component uses client-side rendering to navigate between pages, which can provide a faster and smoother user experience compared to traditional page reloads.</p> <pre><code>import Link from \"next/link\";\nfunction MyComponent() {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;My Component&lt;/h1&gt;\n      &lt;Link href=\"/about\"&gt;\n        &lt;a&gt;About&lt;/a&gt;\n      &lt;/Link&gt;\n    &lt;/div&gt;\n  );\n}\nexport default MyComponent;\n</code></pre>"},{"location":"nextjs/theory/#reference","title":"Reference","text":"<ul> <li>Dynamic Trio by By Grace Huang, pg: 25</li> </ul>"},{"location":"nextjs/theory/rendering-strategies/","title":"Rendering Strategies","text":""},{"location":"nextjs/theory/rendering-strategies/#reference","title":"Reference","text":"<ul> <li>Rendering Strategies</li> <li>Rendering Options on the Web: Server, Client, Static</li> <li>SSR - SSG - ISR - CSR in Next.js\u200a-\u200aThe Ultimate Guide</li> </ul>"},{"location":"nextjs/theory/web-vitals/","title":"Web Vitals","text":"<p>Web Vitals are a set of useful metrics that aim to capture the user experience of a web page. The following web vitals are all included:</p> <ul> <li>Time to First Byte (TTFB)</li> <li>First Contentful Paint (FCP)</li> <li>Largest Contentful Paint (LCP)</li> <li>First Input Delay (FID)</li> <li>Cumulative Layout Shift (CLS)</li> <li>Interaction to Next Paint (INP)</li> </ul>"},{"location":"ssr/difference/","title":"Difference","text":"<p>What is Server Component, React Server Component, Client Component</p> <p>Nice \u2014 let\u2019s clarify the core concepts: Server Component, React Server Component (RSC), and Client Component \u2014 and how they work especially in Next.js App Router.</p>"},{"location":"ssr/difference/#quick-summary-table","title":"\ud83d\udd04 Quick Summary Table","text":"Concept Runs On Can Use <code>useState</code>? Can Fetch Data? When to Use Server Component Server \u274c \u2705 For data fetching + rendering React Server Component Server \u274c \u2705 Fancy term for Server Component (RSC = Server Component) Client Component Browser \u2705 \u274c (usually) For interactivity"},{"location":"ssr/difference/#1-what-is-a-react-server-component-rsc","title":"\ud83e\udde9 1. What is a React Server Component (RSC)?","text":"<p>React Server Components (RSC) are a React feature that lets components run only on the server, and never sent to the browser as JS.</p> \u2714\ufe0f What they can do: <ul> <li>Fetch data from DB or API</li> <li>Render static or dynamic HTML</li> <li>Pass props to Client Components</li> </ul> \u274c What they can\u2019t do: <ul> <li>Use useState, useEffect, or window</li> <li>Handle user interactions</li> </ul> <p>\u2705 How to define:</p> <p>Just create a component without <code>'use client'</code>:</p> <pre><code>// app/posts/page.tsx \u2190 This is a Server Component\nimport { getPosts } from \"@/lib/api\";\n\nexport default async function PostsPage() {\n  const posts = await getPosts();\n  return (\n    &lt;div&gt;\n      {posts.map((post) =&gt; (\n        &lt;p key={post.id}&gt;{post.title}&lt;/p&gt;\n      ))}\n    &lt;/div&gt;\n  );\n}\n</code></pre> <p>In Next.js App Router, every component is a Server Component by default unless you opt-in to Client Component.</p>"},{"location":"ssr/difference/#2-what-is-a-server-component","title":"\ud83e\udde0 2. What is a Server Component?","text":"<p>It\u2019s essentially the same thing as an RSC.</p> <ul> <li>In the context of Next.js, Server Component = React Server Component.</li> <li>It just means: this component executes on the server, not the browser.</li> <li>It's part of React\u2019s new rendering model that allows data-fetching right in your component with <code>await</code>.</li> </ul> <p>\u2705 In Next.js, if you're in <code>/app</code>, and you don\u2019t add <code>'use client'</code>, you\u2019re writing a Server Component.</p>"},{"location":"ssr/difference/#3-what-is-a-client-component","title":"\ud83d\uddb1\ufe0f 3. What is a Client Component?","text":"<p>Client Components run in the browser. You need them for:</p> <ul> <li>Interactivity (<code>onClick</code>, <code>onChange</code>, etc.)</li> <li>State and lifecycle hooks (<code>useState</code>, <code>useEffect</code>)</li> <li>DOM APIs (<code>window</code>, <code>document</code>)</li> <li>Forms, modals, buttons, animations, etc.</li> </ul> <p>\u2705 How to define:</p> <p>Add <code>'use client'</code> at the top:</p> <pre><code>// app/components/Counter.tsx\n\"use client\";\n\nimport { useState } from \"react\";\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n\n  return &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Count: {count}&lt;/button&gt;;\n}\n</code></pre> <p>Then import into a Server Component:</p> <pre><code>// app/page.tsx (Server Component)\nimport Counter from \"./components/Counter\";\n\nexport default function Home() {\n  return (\n    &lt;main&gt;\n      &lt;h1&gt;Welcome&lt;/h1&gt;\n      &lt;Counter /&gt; {/* client component */}\n    &lt;/main&gt;\n  );\n}\n</code></pre>"},{"location":"ssr/difference/#how-server-client-components-work-together","title":"\ud83d\udd04 How Server &amp; Client Components Work Together","text":"<p>You use Server Components for:</p> <ul> <li>Fetching data</li> <li>Heavy rendering</li> <li>Keeping client bundles small</li> </ul> <p>And Client Components for:</p> <ul> <li>UI state</li> <li>Event handling</li> <li>Animations, modals, toggles</li> </ul> <pre><code>// app/page.tsx\nimport Counter from \"./components/Counter\"; // client\nimport PostList from \"./components/PostList\"; // server\n\nexport default function Home() {\n  return (\n    &lt;div&gt;\n      &lt;PostList /&gt;\n      &lt;Counter /&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"ssr/difference/#remember","title":"\ud83e\udde0 Remember:","text":"Feature Server Component (RSC) Client Component <code>await fetch()</code> \u2705 \u274c <code>useState()</code> \u274c \u2705 Runs on Server only Browser Bundle size impact Light (not shipped) Heavier (shipped) Interactivity (events etc) \u274c \u2705 <code>'use client'</code> needed? \u274c \u2705"},{"location":"ssr/folder-structure/","title":"Folder Structure","text":"<pre><code>/app\n  /page.tsx              \u2190 RSC\n  /posts\n    /page.tsx            \u2190 RSC\n    /PostList.tsx        \u2190 RSC (reusable)\n  /components\n    /PostCard.tsx        \u2190 RSC (if no 'use client')\n</code></pre> <p>\ud83d\udcc1 <code>lib/api.ts</code></p> <pre><code>// lib/api.ts\n\nexport async function getPosts() {\n  const res = await fetch(\"https://jsonplaceholder.typicode.com/posts\", {\n    // optional: enable dynamic SSR\n    cache: \"no-store\", // or use 'force-cache' or { next: { revalidate: 60 } } for ISR\n  });\n\n  if (!res.ok) {\n    throw new Error(\"Failed to fetch posts\");\n  }\n\n  const posts = await res.json();\n  return posts;\n}\n</code></pre> <p>\ud83e\uddea Example usage in a Server Component:</p> <pre><code>// app/page.tsx\nimport { getPosts } from \"@/lib/api\";\n\nexport default async function HomePage() {\n  const posts = await getPosts();\n\n  return (\n    &lt;main className=\"p-4\"&gt;\n      &lt;h1 className=\"text-xl font-bold mb-4\"&gt;Latest Posts&lt;/h1&gt;\n      &lt;ul className=\"space-y-2\"&gt;\n        {posts.slice(0, 5).map((post: any) =&gt; (\n          &lt;li key={post.id} className=\"border p-3 rounded-md\"&gt;\n            &lt;h2 className=\"font-semibold\"&gt;{post.title}&lt;/h2&gt;\n            &lt;p className=\"text-sm text-gray-600\"&gt;{post.body}&lt;/p&gt;\n          &lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/main&gt;\n  );\n}\n</code></pre> <p>This setup:</p> <ul> <li>Fetches data server-side using a React Server Component.</li> <li>Uses <code>cache: 'no-store'</code> to ensure it renders fresh data every time (SSR).</li> <li>Works in the App Router (Next.js 13+).</li> </ul> <p>Let me know if you want to add pagination, filtering, or convert this to client-side fetching instead.</p> <p>and where to define the RSC component</p> <p>Great question! In Next.js with the App Router, RSCs (React Server Components) are the default \u2014 so technically, you\u2019re defining a Server Component every time you create a <code>.tsx</code> file in <code>/app/**</code> without <code>'use client'</code> .</p> <p>Let\u2019s break it down:</p>"},{"location":"ssr/overview/","title":"Server-Side Renderings","text":"<p>Server-side rendering (SSR) is basically rendering HTML pages to the client that are served from the server. The client makes a request to the server based on the user event; the server makes the page ready and returns it to the client, which then renders the page. This request is done by the Web browser on the server-side. (1)</p> <ol> <li>React.js Design Patterns by Anthony Onyekachukwu Okonta</li> </ol>"},{"location":"ssr/overview/#when-to-use-server-side-rendering","title":"When to use server-side rendering?","text":"<p>Server-side rendering is not used on every application. The following are some of the reasons why you will choose SSR:</p> <ul> <li>Better user experience</li> <li>Rapid feature development</li> <li>Performance</li> </ul>"},{"location":"ssr/overview/#pros-of-using-nextjs","title":"Pros of using Next.js","text":"<p>The following are some of the pros of using Next.js:</p> <ul> <li>Great for SEO</li> <li>Great community support</li> <li>Fast refresh</li> <li>Speed</li> <li>Image optimization</li> <li>Typescript support</li> <li>Zero config</li> <li>Great developer experience</li> <li>Data fetching</li> <li>Middleware</li> <li>Data security</li> <li>Performance</li> </ul>"},{"location":"ssr/overview/#cons-of-using-nextjs","title":"Cons of using Next.js","text":"<p>The following are some of the cons of using Next.js:</p> <ul> <li>Development and management</li> <li>Routing problems</li> <li>No state manager</li> <li>Limited building time</li> </ul>"},{"location":"ssr/overview/#pre-rendering-in-nextjs","title":"Pre-rendering in Next.js","text":"<p>Next.js pre-renders every page. This means that HTML for each page is generated in advance, instead of it all being done by the client-side. There are two types of Pre-rendering, namely:</p> <ul> <li>Static generation</li> <li>Server-side rendering</li> </ul>"},{"location":"tools/overview/","title":"Overview","text":"<p>Next.js is a powerful React framework that enables developers to build server-side rendering (SSR), static site generation (SSG), and client-side rendering (CSR) applications. To enhance your development experience and productivity, here are some of the best tools and libraries that are valuable for developing Next.js applications:</p> <ol> <li> <p>Development Tools</p> <ul> <li> <p>Next.js DevTools: Official Next.js debugging and inspection tool for understanding your app's structure and performance.</p> </li> <li> <p>ESLint: Linting tool to enforce code quality and best practices. Use the eslint-config-next package for Next.js-specific rules.</p> </li> <li> <p>Prettier: Code formatter to maintain consistent code style.</p> </li> <li> <p>TypeScript: Adds static typing to your Next.js project for better developer experience and fewer runtime errors.</p> </li> <li> <p>VS Code Extensions:</p> <ul> <li>Next.js Snippets: Provides shortcuts for Next.js-specific code.</li> <li>Tailwind CSS IntelliSense: If you're using Tailwind CSS.</li> <li>ESLint and Prettier Integrations: For linting and formatting directly in the editor.</li> </ul> </li> </ul> </li> <li> <p>Styling Tools</p> <ul> <li>Tailwind CSS: Utility-first CSS framework for rapid UI development.</li> <li>Styled Components: CSS-in-JS library for scoped and dynamic styling.</li> <li>Sass/SCSS: For modular and reusable CSS.</li> <li>CSS Modules: Built-in support in Next.js for scoped CSS.</li> <li>Chakra UI: Component library with built-in accessibility and theming.</li> </ul> </li> <li> <p>State Management</p> <ul> <li>Zustand: Lightweight state management library.</li> <li>Recoil: State management library for React with a simple API.</li> <li>Redux Toolkit: Simplified Redux for managing global state.</li> <li>Jotai: Minimalistic state management library with atomic state.</li> </ul> </li> <li> <p>API and Data Fetching</p> <ul> <li>SWR: React Hooks library for data fetching and caching.</li> <li>React Query: Powerful data synchronization and caching library.</li> <li>Axios: HTTP client for making API requests.</li> <li>GraphQL Code Generator: Automatically generates TypeScript types for GraphQL queries.</li> <li>tRPC: End-to-end type-safe API layer for Next.js.</li> </ul> </li> <li> <p>Authentication</p> <ul> <li>NextAuth.js: Complete authentication library for Next.js with support for OAuth, email/password, and more.</li> <li>Clerk: Modern authentication and user management.</li> <li>Supabase: Open-source Firebase alternative with built-in authentication.</li> <li>Auth0: Enterprise-grade authentication and authorization.</li> </ul> </li> <li> <p>Database and Backend Integration</p> <ul> <li>Prisma: Type-safe ORM for working with databases.</li> <li>Supabase: Open-source Firebase alternative with real-time database and authentication.</li> <li>Firebase: Backend-as-a-service for real-time databases, authentication, and hosting.</li> <li>PlanetScale: Serverless MySQL database platform.</li> <li>MongoDB: NoSQL database with Mongoose for schema modeling.</li> </ul> </li> <li> <p>Testing</p> <ul> <li>Jest: JavaScript testing framework.</li> <li>React Testing Library: For testing React components.</li> <li>Cypress: End-to-end testing for Next.js applications.</li> <li>Playwright: Modern end-to-end testing framework.</li> <li>MSW (Mock Service Worker): API mocking for testing.</li> </ul> </li> <li> <p>Performance Optimization</p> <ul> <li>Lighthouse: Built into Chrome DevTools for auditing performance, accessibility, and SEO.</li> <li>Bundle Analyzer: Analyze and optimize your Next.js bundle size.</li> <li>next/image: Built-in image optimization in Next.js.</li> <li>next/script: Optimized third-party script loading.</li> <li>next/dynamic: Lazy load components for better performance.</li> </ul> </li> <li> <p>SEO and Analytics</p> <ul> <li>next-seo: Manage SEO metadata in Next.js.</li> <li>Google Analytics: Track user behavior and performance.</li> <li>Plausible Analytics: Lightweight and privacy-focused analytics.</li> <li>Sitemap Generator: Automatically generate sitemaps for your Next.js app.</li> </ul> </li> <li> <p>Deployment and Hosting</p> <ul> <li>Vercel: The recommended platform for deploying Next.js apps (built by the creators of Next.js).</li> <li>Netlify: Alternative hosting platform with serverless functions.</li> <li>AWS Amplify: Cloud hosting with AWS integration.</li> <li>Docker: Containerize your Next.js app for deployment anywhere.</li> </ul> </li> <li> <p>UI Component Libraries</p> <ul> <li>Material-UI (MUI): React components following Google's Material Design.</li> <li>Ant Design: Enterprise-level UI library.</li> <li>Radix UI: Unstyled, accessible primitives for building custom components.</li> <li>Headless UI: Unstyled, fully accessible UI components.</li> </ul> </li> <li> <p>Internationalization (i18n)</p> <ul> <li>next-i18next: Internationalization library for Next.js.</li> <li>next-translate: Lightweight i18n library for Next.js.</li> </ul> </li> <li> <p>Monitoring and Error Tracking</p> <ul> <li>Sentry: Error tracking and performance monitoring.</li> <li>LogRocket: Session replay and error tracking.</li> <li>Datadog: Full-stack observability and monitoring.</li> </ul> </li> <li> <p>Utility Libraries</p> <ul> <li>Lodash: Utility library for common JavaScript functions.</li> <li>Date-fns: Modern date utility library.</li> <li>Zod: Type-safe schema validation.</li> <li>Formik: Form management library.</li> <li>React Hook Form: Performant and flexible form library.</li> </ul> </li> <li> <p>Static Site Generation (SSG) and Content Management</p> <ul> <li>Markdown: Use Markdown files for content with libraries like remark and gray-matter.</li> <li>Contentlayer: Type-safe content management for Markdown and MDX.</li> <li>MDX: Write JSX in Markdown files.</li> <li>Sanity: Headless CMS for managing content.</li> <li>Strapi: Open-source headless CMS.</li> </ul> </li> </ol> <p>By leveraging these tools, you can significantly improve your Next.js development workflow, build scalable applications, and deliver high-quality user experie</p> <ol> <li> <p>Development Tools</p> <ul> <li>Next.js DevTools \ud83d\udee0\ufe0f</li> <li>ESLint \ud83e\uddf9</li> <li>Prettier \ud83c\udfa8</li> <li>TypeScript \ud83d\udd35</li> <li>VS Code Extensions \ud83d\udcbb</li> </ul> </li> <li> <p>Styling Tools</p> <ul> <li>Tailwind CSS \ud83c\udf43</li> <li>Styled Components \ud83d\udc85</li> <li>Sass/SCSS \ud83c\udf80</li> <li>CSS Modules \ud83e\udde9</li> <li>Chakra UI \u26a1</li> </ul> </li> <li> <p>State Management</p> <ul> <li>Zustand \ud83d\udc3b</li> <li>Recoil \u269b\ufe0f</li> <li>Redux Toolkit \ud83d\udee0\ufe0f</li> <li>Jotai \u269b\ufe0f</li> </ul> </li> <li> <p>API and Data Fetching</p> <ul> <li>SWR \ud83d\udd04</li> <li>React Query \ud83c\udfa3</li> <li>Axios \ud83d\udce1</li> <li>GraphQL Code Generator \ud83e\uddec</li> <li>tRPC \ud83d\udee0\ufe0f</li> </ul> </li> <li> <p>Authentication</p> <ul> <li>NextAuth.js \ud83d\udd10</li> <li>Clerk \ud83d\udd75\ufe0f</li> <li>Supabase \ud83e\udd84</li> <li>Auth0 \ud83d\udd12</li> </ul> </li> <li> <p>Database and Backend Integration</p> <ul> <li>Prisma \ud83d\udee0\ufe0f</li> <li>Supabase \ud83e\udd84</li> <li>Firebase \ud83d\udd25</li> <li>PlanetScale \ud83e\ude90</li> <li>MongoDB \ud83c\udf43</li> </ul> </li> <li> <p>Testing</p> <ul> <li>Jest \ud83c\udccf</li> <li>React Testing Library \ud83e\uddea</li> <li>Cypress \ud83d\udda5\ufe0f</li> <li>Playwright \ud83c\udfad</li> <li>MSW (Mock Service Worker) \ud83d\udee0\ufe0f</li> </ul> </li> <li> <p>Performance Optimization</p> <ul> <li>Lighthouse \ud83d\ude80</li> <li>Bundle Analyzer \ud83d\udcca</li> <li>next/image \ud83d\uddbc\ufe0f</li> <li>next/script \ud83d\udcdc</li> <li>next/dynamic \u26a1</li> </ul> </li> <li> <p>SEO and Analytics</p> <ul> <li>next-seo \ud83d\udd0d</li> <li>Google Analytics \ud83d\udcc8</li> <li>Plausible Analytics \ud83d\udcca</li> <li>Sitemap Generator \ud83d\uddfa\ufe0f</li> </ul> </li> <li> <p>Deployment and Hosting</p> <ul> <li>Vercel \u25b2</li> <li>Netlify \ud83d\udd78\ufe0f</li> <li>AWS Amplify \u2601\ufe0f</li> <li>Docker \ud83d\udc33</li> </ul> </li> <li> <p>UI Component Libraries</p> <ul> <li>Material-UI (MUI) \ud83c\udfa8</li> <li>Ant Design \ud83d\udc1c</li> <li>Radix UI \ud83d\udee0\ufe0f</li> <li>Headless UI \ud83c\udfad</li> </ul> </li> <li> <p>Internationalization (i18n)</p> <ul> <li>next-i18next \ud83c\udf0d</li> <li>next-translate \ud83d\udcdc</li> </ul> </li> <li> <p>Monitoring and Error Tracking</p> <ul> <li>Sentry \ud83d\udea8</li> <li>LogRocket \ud83d\ude80</li> <li>Datadog \ud83d\udc36</li> </ul> </li> <li> <p>Utility Libraries</p> <ul> <li>Lodash \ud83e\uddf0</li> <li>Date-fns \ud83d\udcc5</li> <li>Zod \ud83d\udc0d</li> <li>Formik \ud83d\udcdd</li> <li>React Hook Form \ud83c\udfa3</li> </ul> </li> <li> <p>Static Site Generation (SSG) and Content Management</p> <ul> <li>Markdown \ud83d\udcc4</li> <li>Contentlayer \ud83d\uddc2\ufe0f</li> <li>MDX \ud83d\udcdd</li> <li>Sanity \ud83e\udde0</li> <li>Strapi \ud83e\udd91</li> </ul> </li> </ol>"},{"location":"tools/overview/#reference","title":"Reference","text":"<ul> <li>What are some of the most common tools to use with Next.js </li> <li>Top Next.js Tools for Developers in 2024</li> </ul>"},{"location":"typescript/advanced/","title":"Generics and Advanced Topics","text":""},{"location":"typescript/advanced/#additional-pages-eg-advancedmd-resourcesmd","title":"Additional Pages (e.g., <code>advanced.md</code>, <code>resources.md</code>)","text":"<p>You can continue adding intermediate and advanced concepts, such as:</p> <ul> <li>Generics</li> <li>Interfaces</li> <li>Decorators</li> <li>TypeScript with Modules</li> <li>Advanced Type Inference</li> </ul>"},{"location":"typescript/advanced/#generics-in-typescript","title":"Generics in TypeScript","text":"<p>Generics in TypeScript allow you to write functions, classes, or interfaces that work with any data type while still maintaining type safety. Instead of specifying a concrete type (like <code>string</code> or <code>number</code>), generics allow you to use placeholders that will be replaced with specific types when you use the function, class, or interface.</p> <p>Think of generics as a way to make your code more flexible and reusable.</p> Example Generic Function ExampleExplanation <pre><code>function identity&lt;T&gt;(arg: T): T {\n    return arg;\n}\n\nlet output1 = identity(\"Hello, world!\"); // output1 is of type string\nlet output2 = identity(42); // output2 is of type number\n</code></pre> <ul> <li><code>T</code> is a placeholder that stands for a type that will be determined when the function is called.</li> <li>The function <code>identity</code> will accept an argument of any type (<code>T</code>) and return the same type.</li> </ul>"},{"location":"typescript/advanced/#key-takeaways","title":"Key Takeaways:","text":"<ul> <li>Interfaces define the structure of objects and help you enforce that certain properties or methods exist in objects.</li> <li>Generics allow you to write reusable code that works with different types without losing type safety.</li> </ul>"},{"location":"typescript/advanced/#when-to-use","title":"When to Use:","text":"<ul> <li>Use interfaces when you want to define the shape or structure of an object or a class, including required properties, methods, and optional ones.</li> <li>Use generics when you need to write flexible and reusable functions or classes that can operate with any type while maintaining type safety.</li> </ul>"},{"location":"typescript/advanced/#example-use-case-combining-both","title":"Example Use Case: Combining Both","text":"<p>Let's say we want to create a function that accepts a list of objects, where each object has a <code>name</code> property, and then returns an array of <code>name</code> values.</p> <pre><code>interface Named {\n  name: string;\n}\n\nfunction getNames&lt;T extends Named&gt;(items: T[]): string[] {\n  return items.map((item) =&gt; item.name);\n}\n\nconst people = [\n  { name: \"Alice\", age: 30 },\n  { name: \"Bob\", age: 25 },\n];\n\nconst names = getNames(people);\nconsole.log(names); // Output: [\"Alice\", \"Bob\"]\n</code></pre> <p>In this case:</p> <ul> <li>We use interface <code>Named</code> to specify that the objects should have a name property.</li> <li>We use generics (<code>T extends Named</code>) to allow the function to work with any array of objects that have a <code>name</code> property.</li> </ul>"},{"location":"typescript/advanced/#general-naming-conventions-for-generics","title":"General Naming Conventions for Generics","text":"<ul> <li><code>T</code>: Stands for \"Type\" and is the most common placeholder for a generic type.</li> <li><code>K</code>: Often used for key types (when working with objects or maps).</li> <li><code>V</code>: Often used for value types (when working with key-value pairs).</li> <li><code>U</code>, <code>P</code>, <code>S</code>, etc.: You can use other letters to represent different types depending on their role.</li> </ul>"},{"location":"typescript/basics/","title":"TypeScript Basics","text":""},{"location":"typescript/basics/#variables-and-types","title":"Variables and Types","text":"<p>In TypeScript, you define variables using the <code>let</code>, <code>const</code>, or <code>var</code> keywords, just like in JavaScript, but with the ability to specify types.</p> <pre><code>let isActive: boolean = true;\nlet age: number = 25;\nlet name: string = \"Alice\";\n</code></pre>"},{"location":"typescript/basics/#type-inference","title":"Type Inference","text":"<p>TypeScript can infer the type of a variable if it's not explicitly defined.</p> <pre><code>let greeting = \"Hello, world!\"; // inferred as string\n</code></pre>"},{"location":"typescript/basics/#reference","title":"Reference","text":"<ul> <li>tektutorialshub: Typescript Data Types</li> </ul>"},{"location":"typescript/classes/","title":"Classes in TypeScript","text":"<p>TypeScript supports classes as a part of the ES6 standard.</p> <pre><code>class Person {\n  name: string;\n  age: number;\n\n  constructor(name: string, age: number) {\n    this.name = name;\n    this.age = age;\n  }\n\n  greet() {\n    console.log(`Hello, my name is ${this.name}`);\n  }\n}\n\nlet person = new Person(\"Alice\", 25);\nperson.greet(); // Hello, my name is Alice\n</code></pre>"},{"location":"typescript/classes/#interfaces-in-typescript","title":"Interfaces in TypeScript","text":"<p>An interface in TypeScript is a way to define the structure of an object. It specifies what properties and methods an object should have, without providing the implementation details. This is useful for ensuring that objects adhere to a certain structure and can help with type safety.</p> <pre><code>interface Person {\n  name: string;\n  age: number;\n  greet(): void;\n}\n\nconst person: Person = {\n  name: \"Alice\",\n  age: 30,\n  greet() {\n    console.log(\n      `Hello, my name is ${this.name} and I am ${this.age} years old.`\n    );\n  },\n};\n\nperson.greet();\n</code></pre> <p>In this example:</p> <ul> <li>The <code>Person</code> interface defines the structure: <code>name</code> (string), <code>age</code> (number), and a method <code>greet()</code> that doesn\u2019t return anything (<code>void</code>).</li> <li>The object <code>person</code> must follow this structure, and TypeScript will throw an error if we miss any required properties or the method.</li> </ul>"},{"location":"typescript/classes/#optional-properties","title":"Optional Properties:","text":"<p>You can also make properties optional in an interface by appending a <code>?</code> to the property name</p> <pre><code>interface Person {\n  name: string;\n  age?: number; // age is optional\n}\n\nconst person1: Person = { name: \"Alice\" }; // Works fine\nconst person2: Person = { name: \"Bob\", age: 30 }; // Also works fine\n</code></pre>"},{"location":"typescript/classes/#readonly-properties","title":"Readonly Properties:","text":"<p>If you want to make a property immutable (i.e., it can only be set once), you can use <code>readonly</code>.</p> <pre><code>interface Person {\n  readonly id: number;\n  name: string;\n}\n\nconst person: Person = { id: 1, name: \"Alice\" };\nperson.name = \"Bob\"; // OK\nperson.id = 2; // Error: Cannot assign to 'id' because it is a read-only property.\n</code></pre>"},{"location":"typescript/compiler/","title":"TypeScript Compiler","text":"<ul> <li>TypeScript is transpiled into JavaScript using a compiler.</li> <li>TypeScript being converted into JavaScript means it runs anywhere that JavaScript runs!</li> </ul>"},{"location":"typescript/compiler/#installing-the-compiler","title":"Installing the Compiler","text":"<p>TypeScript has an official compiler which can be installed through <code>npm</code>.</p> <p>Within your <code>npm</code> project, run the following command to install the compiler:</p> bash<pre><code>npm install typescript --save-dev\n</code></pre> <p>You can then run the TypeScript compiler using one of the following commands:</p> <pre><code>npx tsc\n\nyarn tsc\n\npnpm tsc\n</code></pre>"},{"location":"typescript/compiler/#globally-installing-typescript","title":"Globally Installing TypeScript","text":"bash<pre><code>npm install -g typescript\n</code></pre>"},{"location":"typescript/compiler/#configuring-the-compiler","title":"Configuring the compiler","text":"<p>You can have TypeScript create <code>tsconfig.json</code> with the recommended settings with:</p> bash<pre><code>npx tsc --init\n</code></pre> <p>Here is an example of more things you could add to the <code>tsconfig.json</code> file:</p> tsconfig.json<pre><code>{\n  \"include\": [\"src\"],\n  \"compilerOptions\": {\n    \"outDir\": \"./build\"\n  }\n}\n</code></pre>"},{"location":"typescript/compiler/#working-with-typescript-compatible-transpilers","title":"Working with TypeScript-compatible transpilers","text":"<p>There are other tools which convert TypeScript files to JavaScript files</p> <ol> <li>Babel: Babel is a very popular JavaScript transpiler which supports TypeScript files via the plugin @babel/plugin-transform-typescript.</li> <li>swc: swc is a fast transpiler created in Rust which supports many of Babel's features including TypeScript.</li> <li>Sucrase: Sucrase is a Babel fork focused on speed for using in development mode. Sucrase supports TypeScript natively.</li> </ol>"},{"location":"typescript/compiler/#reference","title":"Reference","text":"<ul> <li>TypeScript Compiler :w3chools.com</li> </ul>"},{"location":"typescript/core-concept/","title":"Core Concept","text":""},{"location":"typescript/core-concept/#overview","title":"Overview","text":"<p>When learning TypeScript, there are several core concepts that you should understand to use it effectively. Below is a breakdown of the most important concepts:</p>"},{"location":"typescript/core-concept/#1-static-typing","title":"1. Static Typing","text":"<ul> <li> <p>Type Annotations: TypeScript is statically typed, meaning you can specify the type of a variable, function parameter, or return type.</p> <pre><code>let num: number = 42;\nlet name: string = \"Alice\";\nlet isActive: boolean = true;\n</code></pre> </li> <li> <p>Type Inference: TypeScript automatically infers types when you don\u2019t explicitly specify them. For example:</p> <pre><code>let num = 42; // TypeScript infers `num` as type `number`\n</code></pre> </li> <li> <p>Type System: TypeScript provides several built-in types like <code>number</code>, <code>string</code>, <code>boolean</code>, <code>any</code>, <code>void</code>, <code>null</code>, <code>undefined</code>, and more. You can also define custom types.</p> </li> </ul>"},{"location":"typescript/core-concept/#2-basic-types","title":"2. Basic Types","text":"<ul> <li> <p>Primitive Types: <code>number</code>, <code>string</code>, <code>boolean</code>, <code>null</code>, <code>undefined</code>, <code>symbol</code>, <code>bigint</code>.</p> <pre><code>let isActive: boolean = true;\nlet age: number = 30;\nlet name: string = \"Alice\";\n</code></pre> </li> <li> <p>Arrays and Tuples:</p> <ul> <li> <p>Arrays are collections of a specific type.</p> <pre><code>let numbers: number[] = [1, 2, 3];\n</code></pre> </li> <li> <p>Tuples allow you to define an array with different types of elements at specific positions.</p> <pre><code>let tuple: [string, number] = [\"Alice\", 25];\n</code></pre> </li> </ul> </li> <li> <p>Enums: A way to define a set of named constants.</p> <pre><code>enum Status {\n  Active,\n  Inactive,\n  Pending,\n}\n\nlet userStatus: Status = Status.Active;\n</code></pre> </li> <li> <p><code>any</code> Type: The <code>any</code> type can hold any value and disables type checking for that variable.</p> <pre><code>let data: any = \"Hello\";\ndata = 42; // No error\n</code></pre> </li> </ul>"},{"location":"typescript/core-concept/#3-functions-with-types","title":"3. Functions with Types","text":"<ul> <li> <p>Function Types: You can annotate the types of parameters and the return type of functions.</p> <pre><code>function greet(name: string): string {\n  return `Hello, ${name}`;\n}\n</code></pre> </li> <li> <p>Optional Parameters: Parameters can be made optional using <code>?</code>.</p> <pre><code>function greet(name: string, age?: number): string {\n  return age ? `${name} is ${age} years old` : `${name} is of unknown age`;\n}\n</code></pre> </li> <li> <p>Default Parameters: You can provide default values for parameters.</p> <pre><code>function greet(name: string, age: number = 30): string {\n  return `${name} is ${age} years old`;\n}\n</code></pre> </li> </ul>"},{"location":"typescript/core-concept/#4-interfaces","title":"4. Interfaces","text":"<ul> <li> <p>Defining Object Structures: An interface defines the shape of an object (i.e., the names and types of its properties).</p> <pre><code>interface Person {\n  name: string;\n  age: number;\n}\n\nconst person: Person = {\n  name: \"Alice\",\n  age: 25,\n};\n</code></pre> </li> <li> <p>Optional Properties: You can mark properties as optional using <code>?</code>.</p> <pre><code>interface Person {\n  name: string;\n  age?: number; // Optional property\n}\n</code></pre> </li> <li> <p>Readonly Properties: You can make a property immutable using <code>readonly</code>.</p> <pre><code>interface Point {\n  readonly x: number;\n  readonly y: number;\n}\n</code></pre> </li> </ul>"},{"location":"typescript/core-concept/#5-classes-and-object-oriented-programming","title":"5. Classes and Object-Oriented Programming","text":"<ul> <li> <p>Classes: TypeScript supports object-oriented programming with classes.</p> <pre><code>class Person {\n  name: string;\n  age: number;\n\n  constructor(name: string, age: number) {\n    this.name = name;\n    this.age = age;\n  }\n\n  greet() {\n    console.log(`Hello, ${this.name}`);\n  }\n}\n\nconst person = new Person(\"Alice\", 25);\nperson.greet();\n</code></pre> </li> <li> <p>Inheritance: You can create a subclass that inherits from a parent class.</p> <pre><code>class Animal {\n  name: string;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  speak() {\n    console.log(`${this.name} makes a sound.`);\n  }\n}\n\nclass Dog extends Animal {\n  speak() {\n    console.log(`${this.name} barks.`);\n  }\n}\n\nconst dog = new Dog(\"Buddy\");\ndog.speak(); // \"Buddy barks.\"\n</code></pre> </li> </ul>"},{"location":"typescript/core-concept/#6-generics","title":"6. Generics","text":"<ul> <li> <p>Reusable Components: Generics allow you to create functions, classes, or interfaces that work with any data type.</p> <pre><code>function identity&lt;T&gt;(arg: T): T {\n  return arg;\n}\n\nlet result1 = identity(5); // result1 is of type `number`\nlet result2 = identity(\"hello\"); // result2 is of type `string`\n</code></pre> </li> <li> <p>Generic Constraints: You can constrain the types that can be used with a generic.</p> <pre><code>function logLength&lt;T extends { length: number }&gt;(item: T): number {\n  return item.length;\n}\n</code></pre> </li> </ul>"},{"location":"typescript/core-concept/#7-type-aliases","title":"7. Type Aliases","text":"<ul> <li> <p>Type Aliases: You can create new names for types, including complex ones like unions or intersections.</p> <pre><code>type StringOrNumber = string | number; // Union type\n\nlet value: StringOrNumber = \"Hello\"; // OK\nvalue = 42; // OK\n</code></pre> </li> </ul>"},{"location":"typescript/core-concept/#8-union-and-intersection-types","title":"8. Union and Intersection Types","text":"<ul> <li> <p>Union Types (<code>|</code>): A value can be one of several types.</p> <pre><code>let id: number | string = 123;\nid = \"abc\"; // Valid\n</code></pre> </li> <li> <p>Intersection Types (<code>&amp;</code>): Combines multiple types into one.</p> <pre><code>interface Person {\n  name: string;\n}\n\ninterface Contact {\n  email: string;\n}\n\ntype Employee = Person &amp; Contact;\n\nconst employee: Employee = {\n  name: \"Alice\",\n  email: \"alice@example.com\",\n};\n</code></pre> </li> </ul>"},{"location":"typescript/core-concept/#9-modules-and-namespaces","title":"9. Modules and Namespaces","text":"<ul> <li> <p>Modules: TypeScript uses <code>import</code> and <code>export</code> to organize code into separate files.</p> <pre><code>// file: person.ts\nexport interface Person {\n  name: string;\n  age: number;\n}\n\n// file: main.ts\nimport { Person } from \"./person\";\nconst person: Person = { name: \"Alice\", age: 25 };\n</code></pre> </li> <li> <p>Namespaces: Group related code together, but modules (via <code>import/export</code>) are generally preferred now.</p> <pre><code>namespace Animal {\n  export class Dog {\n    name: string;\n    constructor(name: string) {\n      this.name = name;\n    }\n  }\n}\n\nlet myDog = new Animal.Dog(\"Buddy\");\n</code></pre> </li> </ul>"},{"location":"typescript/core-concept/#10-type-assertions","title":"10. Type Assertions","text":"<ul> <li> <p>Type Assertion: You can tell TypeScript to treat a value as a certain type (bypassing the compiler's type checking).</p> <pre><code>let someValue: any = \"Hello\";\nlet strLength: number = (someValue as string).length;\n</code></pre> </li> </ul>"},{"location":"typescript/core-concept/#11-advanced-types","title":"11. Advanced Types","text":"<ul> <li> <p>Conditional Types: Types that depend on a condition.</p> <pre><code>type IsString&lt;T&gt; = T extends string ? \"Yes\" : \"No\";\ntype A = IsString&lt;string&gt;; // \"Yes\"\ntype B = IsString&lt;number&gt;; // \"No\"\n</code></pre> </li> <li> <p>Mapped Types: Create new types by transforming existing ones.</p> <pre><code>type ReadOnly&lt;T&gt; = {\n  readonly [K in keyof T]: T[K];\n};\n</code></pre> </li> </ul>"},{"location":"typescript/core-concept/#summary","title":"Summary","text":"<p>These are the main concepts that will help you understand and use TypeScript effectively:</p> <ul> <li>Static typing and type annotations</li> <li>Primitive types, arrays, tuples, and enums</li> <li>Interfaces and type aliases</li> <li>Classes, inheritance, and object-oriented programming</li> <li>Generics for reusable components</li> <li>Union and intersection types</li> <li>Modules, namespaces, and file organization</li> <li>Type assertions and advanced types</li> </ul> <p>Once you're comfortable with these, you'll have a solid foundation in TypeScript!</p>"},{"location":"typescript/core-concept/#question","title":"Question","text":"<p>Yes, when using TypeScript in a React project, all files that contain TypeScript code should have the <code>.ts</code> or <code>.tsx</code> extensions, depending on whether they contain JSX.</p> <p>Here\u2019s a breakdown of how to handle file extensions in TypeScript:</p> <p>1. For TypeScript files without JSX:</p> <ul> <li>File extension: .ts</li> <li>These files contain only TypeScript code (e.g., utility functions, API services, Redux slices, etc.), but no JSX syntax.</li> </ul> <p>Example:</p> <ul> <li><code>utils/helpers.ts</code>, <code>redux/slices/userSlice.ts</code>, <code>api/services/userApi.ts</code></li> </ul> <p>2. For TypeScript files with JSX:</p> <pre><code>File extension: `.tsx`\nThese files contain both TypeScript and JSX (e.g., React components).\n</code></pre> <p>Example:</p> <ul> <li><code>components/UserList.tsx</code>, <code>views/Home/Home.tsx</code>, <code>App.tsx</code></li> </ul> <p>Why is this important?</p> <ul> <li>TypeScript\u2019s compiler needs to know whether or not it should expect JSX syntax. Files with <code>.tsx</code> extensions indicate that the file contains JSX, and TypeScript will allow JSX syntax in them.</li> <li><code>.ts</code> files are for TypeScript-only code, where JSX is not allowed. If you tried to use JSX syntax in a <code>.ts</code> file, TypeScript would throw an error.</li> </ul> Example Example of React Component: UserList.tsx (a component with JSX)<pre><code>import React from 'react';\n\nconst UserList: React.FC = () =&gt; {\n    return (\n        &lt;div&gt;\n        &lt;h1&gt;User List&lt;/h1&gt;\n        {/* JSX syntax */}\n        &lt;/div&gt;\n    );\n};\n\nexport default UserList;\n</code></pre> userApi.ts (a service file without JSX)<pre><code>import axios from 'axios';\n\nconst userApi = {\n    fetchUsers: async () =&gt; {\n        const response = await axios.get('/users');\n        return response.data;\n    }\n};\n\nexport default userApi;\n</code></pre> <p>Summary:</p> <ul> <li>Use <code>.ts</code> for TypeScript files that don\u2019t include JSX.</li> <li>Use <code>.tsx</code> for TypeScript files that include JSX.</li> </ul> <p>This way, your code will remain consistent, and TypeScript will be able to process the files correctly.</p>"},{"location":"typescript/functions/","title":"Functions in TypeScript","text":"<p>Functions in TypeScript are just like in JavaScript, but with optional type annotations for the arguments and return values.</p>"},{"location":"typescript/functions/#function-signature","title":"Function Signature","text":"<pre><code>function greet(name: string): string {\n  return `Hello, ${name}!`;\n}\n</code></pre>"},{"location":"typescript/functions/#optional-and-default-parameters","title":"Optional and Default Parameters","text":"<p>You can also define optional parameters and default values:</p> <pre><code>function greet(name: string, age?: number): string {\n  if (age) {\n    return `Hello, ${name}, age ${age}`;\n  }\n  return `Hello, ${name}`;\n}\n</code></pre>"},{"location":"typescript/installation/","title":"Typescript","text":""},{"location":"typescript/installation/#what-is-typescript","title":"What is TypeScript?","text":"<p>TypeScript is JavaScript with added syntax for types.</p> <p>TypeScript is a syntactic superset of JavaScript which adds static typing.</p> <p>This basically means that TypeScript adds syntax on top of JavaScript, allowing developers to add types.</p> <p>TypeScript being a \"Syntactic Superset\" means that it shares the same base syntax as JavaScript, but adds something to it.</p>"},{"location":"typescript/installation/#how-do-i-use-typescript","title":"How do I use TypeScript?","text":"<p>A common way to use TypeScript is to use the official TypeScript compiler, which transpiles TypeScript code into JavaScript.</p> <p>The next section shows how to get the compiler setup for a local project.</p> <p>Some popular code editors, such as Visual Studio Code, have built-in TypeScript support and can show errors as you write code!</p> <p>TypeScript uses compile time type checking. Which means it checks if the specified types match before running the code, not while running the code.</p> <p>TypeScript allows developers to add types to JavaScript.</p> <p></p> <p></p>"},{"location":"typescript/installation/#overview","title":"Overview","text":"<p>To install React Redux and React Redux Toolkit in a TypeScript project using pnpm, follow these steps:</p> <p>Step 1: Install the necessary packages</p> <p>You need to install the following packages:</p> <ul> <li><code>react-redux</code>: The official Redux bindings for React.</li> <li><code>@reduxjs/toolkit</code>: The official Redux Toolkit, which simplifies working with Redux.</li> <li><code>@types/react-redux</code>: TypeScript types for React Redux.</li> </ul> <p>Install with pnpm</p> <p>In your project directory, run the following command:</p> <pre><code>pnpm add react-redux @reduxjs/toolkit @types/react-redux\n</code></pre> <p>This command will:</p> <ul> <li>Install <code>react-redux</code> for React bindings.</li> <li>Install <code>@reduxjs/toolkit</code> for simplified Redux setup.</li> <li>Install <code>@types/react-redux</code> for TypeScript types to ensure full type safety.</li> </ul>"},{"location":"typescript/installation/#reference","title":"Reference","text":"<ul> <li>TypeScript Tutorial: w3schools.com</li> <li>Medium: What is Typescript ?</li> <li>Salesforce: How to Use TypeScript with Salesforce \u2013 Part 1</li> <li>Blog: TypeScript vs JavaScript \u2013 Understand the Difference</li> </ul>"},{"location":"typescript/intro/","title":"Introduction to TypeScript","text":"<p>Welcome to the TypeScript learning guide! This documentation will take you from basic to intermediate TypeScript concepts.</p>"},{"location":"typescript/intro/#what-is-typescript","title":"What is TypeScript?","text":"<p>TypeScript is a typed superset of JavaScript that adds static types. It can be compiled into plain JavaScript, and helps with early error detection and better tooling support.</p>"},{"location":"typescript/intro/#topics-covered","title":"Topics Covered:","text":"<ul> <li>Basics of TypeScript</li> <li>Functions in TypeScript</li> <li>Classes and Interfaces</li> <li>Generics and Advanced Topics</li> </ul>"},{"location":"typescript/one-hour-ts/","title":"1 hour","text":""},{"location":"typescript/one-hour-ts/#overview","title":"Overview","text":"<p>Learning TypeScript in one hour is definitely a challenge, but it's possible to get a good understanding of the basics and learn how to start using it effectively. I'll focus on key concepts, and by the end, you should be able to write simple TypeScript code and understand how it integrates with JavaScript.</p>"},{"location":"typescript/one-hour-ts/#outline-for-1-hour-typescript-crash-course","title":"Outline for 1-Hour TypeScript Crash Course","text":"0-10 minutes: Introduction to TypeScript <p>What is TypeScript?</p> <ul> <li>TypeScript is a statically typed superset of JavaScript.</li> <li>It adds types, interfaces, and other features to help catch errors early and improve code quality.</li> <li>Transpilation: TypeScript code is compiled to JavaScript (it doesn't run natively in browsers).</li> </ul> <p>Why Use TypeScript?</p> <ul> <li>Type safety: Helps avoid common runtime errors (e.g., accessing properties of <code>undefined</code>).</li> <li>Autocompletion: Better IDE support.</li> <li>Refactoring: Makes large projects easier to maintain.</li> </ul> <p>Install TypeScript:</p> <ul> <li> <p>You can install TypeScript globally via npm:</p> <pre><code>npm install -g typescript\n</code></pre> </li> <li> <p>To compile TypeScript to JavaScript:</p> <pre><code>tsc myfile.ts\n</code></pre> </li> </ul> 10-25 minutes: Basic Syntax and Types <ul> <li> <p>Basic Types: TypeScript provides static types that help enforce rules about how values are used. Here are the most common ones:</p> <pre><code>let num: number = 42;\nlet isActive: boolean = true;\nlet name: string = \"Alice\";\nlet anyValue: any = \"Can be anything\";\n</code></pre> </li> <li> <p>Arrays and Tuples:</p> <pre><code>let numbers: number[] = [1, 2, 3];\nlet tuple: [string, number] = [\"Hello\", 42]; // Tuple of a string and a number\n</code></pre> </li> <li> <p>Object Types: Define the shape of an object using an interface or inline object types:</p> <pre><code>let person: { name: string, age: number } = { name: \"Alice\", age: 25 };\n</code></pre> </li> <li> <p>Functions with Types: Functions in TypeScript have type annotations for parameters and return types:</p> <pre><code>function greet(name: string): string {\n    return \"Hello, \" + name;\n}\n</code></pre> </li> </ul> 25-40 minutes: Intermediate Concepts <ul> <li> <p>Interfaces: Interfaces define the structure of objects. They help you enforce types across your codebase:</p> <pre><code>interface Person {\n    name: string;\n    age: number;\n}\n\nconst person: Person = { name: \"Alice\", age: 30 };\n</code></pre> </li> <li> <p>Type Aliases: Type aliases can simplify complex types:</p> <pre><code>type StringOrNumber = string | number;\n\nlet value: StringOrNumber = 10;\nvalue = \"Hello\"; // OK\n</code></pre> </li> <li> <p>Union Types: TypeScript allows you to specify a value can be one of several types:</p> <pre><code>function showMessage(message: string | number) {\n    console.log(message);\n}\n\nshowMessage(\"Hello\");\nshowMessage(42);\n</code></pre> </li> <li> <p>Type Assertion (like casting in other languages):</p> <pre><code>let someValue: any = \"This is a string\";\nlet strLength: number = (someValue as string).length;\n</code></pre> </li> </ul> 40-50 minutes: Advanced Concepts (Optional for Speed) <ul> <li> <p>Generics: Generics allow you to create reusable components that work with any data type:</p> <pre><code>function identity&lt;T&gt;(arg: T): T {\n    return arg;\n}\n\nlet result = identity(42); // result is of type number\nlet stringResult = identity(\"hello\"); // result is of type string\n</code></pre> </li> <li> <p>Classes and Inheritance: TypeScript supports classes and object-oriented programming:</p> <pre><code>class Animal {\n    name: string;\n    constructor(name: string) {\n        this.name = name;\n    }\n    speak() {\n        console.log(`${this.name} makes a noise`);\n    }\n}\n\nclass Dog extends Animal {\n    speak() {\n        console.log(`${this.name} barks`);\n    }\n}\n\nconst dog = new Dog(\"Buddy\");\ndog.speak(); // \"Buddy barks\"\n</code></pre> </li> <li> <p>Modules: TypeScript allows you to use import and export to split your code into multiple files:</p> <pre><code>// person.ts\nexport interface Person {\n    name: string;\n    age: number;\n}\n\n// main.ts\nimport { Person } from './person';\nconst person: Person = { name: \"Alice\", age: 25 };\n</code></pre> </li> </ul> 50-60 minutes: Putting It All Together <ul> <li> <p>Write a Small TypeScript Project: Try writing a small TypeScript program that uses the concepts above. For example, create a simple class-based system for a \"Book\" and \"Library\" to practice using classes, interfaces, and types:</p> <pre><code>interface Book {\n    title: string;\n    author: string;\n    year: number;\n}\n\nclass Library {\n    books: Book[] = [];\n\n    addBook(book: Book) {\n        this.books.push(book);\n    }\n\n    listBooks() {\n        this.books.forEach(book =&gt; console.log(`${book.title} by ${book.author}, ${book.year}`));\n    }\n}\n\nconst library = new Library();\nlibrary.addBook({ title: \"1984\", author: \"George Orwell\", year: 1949 });\nlibrary.listBooks();\n</code></pre> </li> </ul> <p>This example uses interfaces, classes, and basic types.</p>"},{"location":"typescript/one-hour-ts/#wrap-up-next-steps","title":"Wrap-Up &amp; Next Steps","text":"<ul> <li>You now have a basic understanding of TypeScript! You can start using it in small projects and gradually dive deeper into more advanced concepts.</li> <li> <p>Next Steps:</p> </li> <li> <p>Practice by converting existing JavaScript code to TypeScript.</p> </li> <li>Explore the TypeScript documentation: TypeScript Handbook.</li> <li>Try using TypeScript with frameworks like Angular or React to see its benefits in larger applications.</li> </ul>"},{"location":"typescript/react-fc/example/","title":"Example","text":""},{"location":"typescript/react-fc/example/#example","title":"Example","text":"<p>so using React.FC expects the return statements? is it correct</p> <p>Yes, that's correct! When you use <code>React.FC</code>, it expects your component to return <code>valid JSX</code> (or <code>ReactNode</code>), as it infers the return type to be a React element.</p> Example <pre><code>import React from \"react\";\nimport type { FormProps } from \"antd\";\nimport { Button, Checkbox, Form, Input } from \"antd\";\n\ntype FieldType = {\n    username?: string;\n    password?: string;\n    remember?: string;\n};\n\nconst onFinish: FormProps&lt;FieldType&gt;[\"onFinish\"] = (values) =&gt; {\n    console.log(\"Success:\", values);\n};\n\nconst onFinishFailed: FormProps&lt;FieldType&gt;[\"onFinishFailed\"] = (errorInfo) =&gt; {\n    console.log(\"Failed:\", errorInfo);\n};\n\nconst App: React.FC = () =&gt; (\n    &lt;Form\n        name=\"basic\"\n        labelCol={{ span: 8 }}\n        wrapperCol={{ span: 16 }}\n        style={{ maxWidth: 600 }}\n        initialValues={{ remember: true }}\n        onFinish={onFinish}\n        onFinishFailed={onFinishFailed}\n        autoComplete=\"off\"\n    &gt;\n        &lt;Form.Item&lt;FieldType&gt;\n            label=\"Username\"\n            name=\"username\"\n            rules={[{ required: true, message: \"Please input your username!\" }]}\n        &gt;\n            &lt;Input /&gt;\n        &lt;/Form.Item&gt;\n\n        &lt;Form.Item&lt;FieldType&gt;\n            label=\"Password\"\n            name=\"password\"\n            rules={[{ required: true, message: \"Please input your password!\" }]}\n        &gt;\n            &lt;Input.Password /&gt;\n        &lt;/Form.Item&gt;\n\n        &lt;Form.Item&lt;FieldType&gt; name=\"remember\" valuePropName=\"checked\" label={null}&gt;\n            &lt;Checkbox&gt;Remember me&lt;/Checkbox&gt;\n        &lt;/Form.Item&gt;\n\n        &lt;Form.Item label={null}&gt;\n            &lt;Button type=\"primary\" htmlType=\"submit\"&gt;\n                Submit\n            &lt;/Button&gt;\n        &lt;/Form.Item&gt;\n    &lt;/Form&gt;\n);\n\nexport default App;\n</code></pre> <p>Great question! The key thing to understand here is that React.FC (FunctionComponent) is a shortcut for defining a functional component in TypeScript, but it doesn't enforce a <code>return</code> statement in the sense of needing an explicit return like other JavaScript functions. The <code>App</code> component implicitly returns JSX because that's the behavior of functional components in React.</p>"},{"location":"typescript/react-fc/example/#why-it-doesnt-need-a-return-statement","title":"Why It Doesn't Need a <code>return</code> Statement:","text":"<ol> <li> <p>Implicit Return: In JSX, the return of the JSX element is implicit. When you write JSX directly inside a function body like this:</p> <pre><code>const App: React.FC = () =&gt; &lt;Form&gt;...&lt;/Form&gt;;\n</code></pre> <p>It's equivalent to:</p> <pre><code>const App: React.FC = () =&gt; {\n  return &lt;Form&gt;...&lt;/Form&gt;;\n};\n</code></pre> <p>The parentheses <code>()</code> after the arrow function indicate an implicit return of JSX (the <code>Form</code> component in this case). This shorthand is common in React components.</p> </li> <li> <p>React.FC: Using <code>React.FC</code> does not require a <code>return</code> statement in a conventional way because the implicit return feature of arrow functions is being used. So, in your example, <code>React.FC</code> is just a typing convention, and the actual component implicitly returns the JSX in the form of the <code>Form</code> component.</p> </li> </ol>"},{"location":"typescript/react-fc/example/#summary","title":"Summary:","text":"<p><code>React.FC</code> does not change the behavior of how JSX is returned. The component still returns JSX implicitly through the arrow function syntax. The parentheses <code>()</code> after the arrow function are what make this return implicit, so you don't need to explicitly write <code>return</code> if you're writing JSX directly.</p>"},{"location":"typescript/react-fc/intro/","title":"Intro","text":"<p><code>React.FC</code> (or <code>React.FunctionComponent</code>) is a TypeScript type that helps define functional components in React with proper type checking. It's a generic type provided by React to make it easier to work with functional components in TypeScript.</p>"},{"location":"typescript/react-fc/intro/#what-is-reactfc","title":"What is React.FC?","text":"<p>React.FC is a built-in TypeScript type that is specifically designed for defining functional components. It automatically provides some helpful type inference, such as:</p> <ol> <li>Props type: When you use React.FC, TypeScript infers the shape of props that the component will receive.</li> <li>Children prop: By default, it adds the children prop to your component, so you don't have to explicitly type it unless you want to override it.</li> <li>Return type: It ensures the component returns valid JSX/React elements.</li> </ol> <p>Here's a breakdown of what React.FC provides:</p> <ul> <li>Type for props: <code>React.FC</code> expects a type argument that describes the shape of the props. If no props are used, you can pass {}.</li> <li>Children typing: If your component renders children, <code>React.FC</code> automatically gives you the correct type for children (i.e., ReactNode).</li> <li>Return type inference: It ensures that your component returns a valid React element.</li> </ul>"},{"location":"typescript/react-fc/intro/#why-do-we-need-reactfc","title":"Why do we need React.FC?","text":"<p>In TypeScript, <code>React.FC</code> provides better type safety and code readability by enforcing rules about props and return types. Here's why you might want to use it:</p> <ol> <li> <p>Automatic typing of props: If you have a component that accepts props, you can define the shape of the props once, and <code>React.FC</code> will enforce this type for you. This reduces the chance of errors where props are used incorrectly.</p> </li> <li> <p>Children support: React components often need to render children. <code>React.FC</code> automatically handles the children prop, so you don't need to explicitly define it if you're using it. This makes your code more concise and easier to read.</p> </li> <li> <p>Consistent return types: <code>React.FC</code> ensures that your component returns valid JSX. It helps prevent mistakes where a function might not return anything or return something that isn't a valid React element.</p> </li> </ol> Example Example with React.FC:Explanation <pre><code>import React from \"react\";\n\ntype ButtonProps = {\n    text: string;\n};\n\nconst Button: React.FC&lt;ButtonProps&gt; = ({ text }) =&gt; {\n    return &lt;button&gt;{text}&lt;/button&gt;;\n};\n\nexport default Button;\n</code></pre> <ul> <li><code>ButtonProps</code> defines the <code>text</code> prop.</li> <li><code>React.FC&lt;ButtonProps&gt;</code> tells TypeScript that this component expects <code>ButtonProps</code> and will return a valid JSX element.</li> </ul>"},{"location":"typescript/react-fc/intro/#what-happens-if-we-dont-use-reactfc","title":"What happens if we don't use React.FC?","text":"<p>You are not required to use <code>React.FC</code>. In fact, it's perfectly fine to define functional components without it, especially if you don't need <code>children</code> or prefer to define your own types. Here's an example of a component without <code>React.FC</code>:</p> <pre><code>import React from \"react\";\n\ntype ButtonProps = {\n  text: string;\n};\n\nconst Button = ({ text }: ButtonProps) =&gt; {\n  return &lt;button&gt;{text}&lt;/button&gt;;\n};\n\nexport default Button;\n</code></pre> <p>In this case:</p> <ul> <li>You're still explicitly typing the <code>ButtonProps</code> and passing them as arguments.</li> <li>There's no need for <code>React.FC</code> because you're not using the default <code>children</code> prop and you explicitly type the return type (JSX) by just defining the props.</li> </ul>"},{"location":"typescript/react-fc/intro/#key-differences-and-trade-offs","title":"Key Differences and Trade-offs:","text":"<ol> <li> <p>No <code>children</code> support: If you don't use <code>React.FC</code>, and you want to support children, you will need to type the <code>children</code> prop manually. For example:</p> <pre><code>type ButtonProps = {\n  text: string;\n  children?: React.ReactNode;\n};\n</code></pre> </li> <li> <p>Verbose typing: Without <code>React.FC</code>, you might need to manually type the return type for your component if it's not just JSX:</p> <pre><code>const Button = ({ text }: ButtonProps): JSX.Element =&gt; {\n  return &lt;button&gt;{text}&lt;/button&gt;;\n};\n</code></pre> <p><code>React.FC</code> automatically infers that the return type should be <code>JSX.Element</code>.</p> </li> <li> <p>No enforced <code>children</code> prop: If you use <code>React.FC</code>, you get <code>children</code> as an implicit part of your props. If you don't want it, you can either remove it from your type or override it, but generally, you won't need to define it manually.</p> </li> </ol>"},{"location":"typescript/react-fc/intro/#conclusion","title":"Conclusion:","text":"<ul> <li>Use <code>React.FC</code> if you want automatic typing for <code>children</code> and prefer the convenience of having <code>React</code> types inferred (for props and return values).</li> <li>Don't use <code>React.FC</code> if you prefer more control and don't need automatic handling of <code>children</code>. You might also avoid it for simpler components that don't require these features.</li> </ul> <p>While <code>React.FC</code> is widely used, it's not a strict requirement. Some developers choose to avoid it for various reasons, such as wanting more explicit typing control or reducing unnecessary complexity.</p>"},{"location":"typescript/react-fc/react-fc/","title":"React.FC","text":""},{"location":"typescript/react-fc/react-fc/#when-to-use","title":"When to use","text":"<p>In a TypeScript-based React application, whether to use <code>React.FC</code> (or <code>React.FunctionComponent</code>) or not depends on the specific needs of your components and the style guide you follow. I'll go through both scenarios\u2014when to use and when not to use <code>React.FC</code>\u2014along with real-time examples for each case.</p> Note When to Use <code>React.FC</code>When Not to Use <code>React.FC</code> <ol> <li> <p>When Your Component Accepts Children</p> <p><code>React.FC</code>automatically includes the <code>children</code> prop. If your component is designed to accept children (nested content or components), using <code>React.FC</code> is convenient, as it will automatically infer the type for <code>children</code>.</p> Example <pre><code>import React from 'react';\n\ninterface CardProps {\n    title: string;\n    content: string;\n}\n\nconst Card: React.FC&lt;CardProps&gt; = ({ title, content, children }) =&gt; {\n    return (\n        &lt;div className=\"card\"&gt;\n            &lt;h2&gt;{title}&lt;/h2&gt;\n            &lt;p&gt;{content}&lt;/p&gt;\n            &lt;div&gt;{children}&lt;/div&gt; {/* children are automatically typed */}\n        &lt;/div&gt;\n    );\n};\n</code></pre> <ul> <li> <p>Why use <code>React.FC</code> here?</p> <ul> <li>This component is designed to accept <code>children</code>. By using <code>React.FC</code>, we don't have to explicitly define the <code>children</code> prop in the <code>CardProps</code> interface. It's automatically included and typed as <code>ReactNode</code>.</li> <li>This is useful if you want to make sure that the component works as a wrapper that can accept arbitrary child elements.</li> </ul> </li> </ul> </li> <li> <p>When You Want a Simple and Consistent Type for Functional Components</p> <p>Using <code>React.FC</code> provides a consistent way of defining functional components with type inference for <code>props</code> and <code>children</code>, especially in large codebases where you want to keep things uniform.</p> Example <pre><code>import React from 'react';\n\ninterface ButtonProps {\n    label: string;\n    onClick: () =&gt; void;\n}\n\nconst Button: React.FC&lt;ButtonProps&gt; = ({ label, onClick }) =&gt; {\n    return &lt;button onClick={onClick}&gt;{label}&lt;/button&gt;;\n};\n</code></pre> <ul> <li> <p>Why use <code>React.FC</code> here?</p> </li> <li> <p>The <code>Button</code> component only accepts <code>label</code> and <code>onClick</code> props, but it is simple and clear. <code>React.FC</code> automatically ensures that <code>children</code> can also be passed (though it's not used in this case).</p> </li> <li>It reduces boilerplate if you are using <code>children</code> in other components in your application, and it provides a consistent style.</li> </ul> </li> </ol> <ol> <li> <p>When Your Component Does Not Need <code>children</code></p> <p>If your component does not need to accept <code>children</code>, using <code>React.FC</code> might be unnecessary and might lead to potential confusion, as <code>children</code> will be inferred by TypeScript even though it's not used. In such cases, manually typing the props is simpler and avoids any confusion about unnecessary <code>children</code> support.</p> Example <pre><code>import React from 'react';\n\ninterface AvatarProps {\n    imageUrl: string;\n    altText: string;\n}\n\nconst Avatar = ({ imageUrl, altText }: AvatarProps) =&gt; {\n    return &lt;img src={imageUrl} alt={altText} /&gt;;\n};\n</code></pre> <ul> <li> <p>Why not use <code>React.FC</code> here?</p> <ul> <li><code>Avatar</code> is a simple component that does not need <code>children</code>. Adding <code>React.FC</code> here would unnecessarily add <code>children</code> as part of the type, even though it isn't required. This can make the code slightly more complex or confusing for others.</li> </ul> </li> </ul> </li> <li> <p>When You Want Explicit Typing for props</p> <p>Sometimes, being more explicit about what your component expects and handling the props manually is preferred. This can be helpful in cases where you want to ensure that only the props you explicitly define are passed in.</p> Example <pre><code>import React from 'react';\n\ninterface ProfileProps {\n    username: string;\n    age: number;\n}\n\nconst Profile = ({ username, age }: ProfileProps) =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;{username}&lt;/h1&gt;\n            &lt;p&gt;Age: {age}&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre> <ul> <li> <p>Why not use <code>React.FC</code> here?</p> <ul> <li>By defining <code>ProfileProps</code> and explicitly typing the props in the component signature, you're making the code clear and explicit.</li> <li>This can help avoid unnecessary automatic behaviors that <code>React.FC</code> introduces, like the implicit <code>children</code> prop.</li> <li>If your component doesn't need <code>children</code>, it's clearer and more explicit to not use <code>React.FC</code>.</li> </ul> </li> </ul> </li> <li> <p>When You Want to Avoid Potential Unnecessary Re-renders</p> <p>In some cases, the use of <code>React.FC</code> might lead to unnecessary complexity because it adds some implicit behavior (like <code>children</code>), which could potentially trigger re-renders or create complexity in the props typing.</p> Example <pre><code>import React, { useState } from 'react';\n\ninterface CounterProps {\n    initialCount: number;\n}\n\nconst Counter = ({ initialCount }: CounterProps) =&gt; {\n    const [count, setCount] = useState(initialCount);\n\n    return (\n        &lt;div&gt;\n            &lt;h2&gt;Count: {count}&lt;/h2&gt;\n            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre> <ul> <li> <p>Why not use <code>React.FC</code> here?</p> <ul> <li><code>Counter</code> only needs <code>initialCount</code> as a prop, and <code>children</code> aren't required. Using <code>React.FC</code> in this case would introduce unnecessary props (<code>children</code>), making it harder to track what's required and potentially leading to unnecessary re-renders or confusion about which props the component actually accepts.</li> <li>When you manually define <code>props</code>, you have full control over what is passed into your component.</li> </ul> </li> </ul> </li> </ol> <p>Summary of When to Use and When Not to Use <code>React.FC</code></p> Use <code>React.FC</code> Don't Use <code>React.FC</code> When your component needs to accept <code>children</code>. When your component doesn't need <code>children</code>. When you want a consistent, simpler type for functional components. When you prefer more explicit typing for props. When you want automatic type inference for <code>children</code>. When you want to avoid implicit behavior (like <code>children</code>) in the component. When your component is a wrapper or layout component (e.g., cards, panels). When the component is simple and doesn't require extra functionality. <p>Conclusion</p> <ul> <li>Use <code>React.FC</code> when you want to quickly define functional components that accept <code>children</code> or when you prefer having consistent typing for props and <code>children</code>.</li> <li>Avoid <code>React.FC</code> when you don't need <code>children</code> or when you want to keep your components' typings as explicit and simple as possible.</li> </ul> <p>While there's no hard rule, a lot of modern TypeScript React codebases avoid <code>React.FC</code> because it can introduce unnecessary complexity when <code>children</code> are not needed. Ultimately, it boils down to coding style preferences and the needs of your application.</p>"}]}